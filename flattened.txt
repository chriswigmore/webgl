// ====
// C:\inetpub\wwwroot\WebGL\code\shaders\shader2d.frag
// ----
precision mediump float;

void main(void) {
	gl_FragColor = vec4(1.0, 1.0, 0.0, 0.5);
}


// ====
// C:\inetpub\wwwroot\WebGL\code\shaders\shader2d.vert
// ----
attribute vec3 aVtxPos;

uniform mat4 uMvMatrix;
uniform mat4 uPMatrix;

void main(void) {
	gl_Position = uPMatrix * uMvMatrix * vec4(aVtxPos, 1.0);
}


// ====
// C:\inetpub\wwwroot\WebGL\code\shaders\shader3d.frag
// ----
precision mediump float;

varying vec3 vLightWeight;

void main(void) {
	vec3 color = vec3(1.0, 1.0, 1.0);
	gl_FragColor = vec4(color * vLightWeight, 1.0);
}


// ====
// C:\inetpub\wwwroot\WebGL\code\shaders\shader3d.vert
// ----
attribute vec3 aVtxPos;
attribute vec3 aVtxNor;

uniform mat4 uMvMatrix;
uniform mat4 uPMatrix;
uniform vec3 uLightDirection;

varying vec3 vLightWeight;

void main(void) {
	gl_Position = uPMatrix * uMvMatrix * vec4(aVtxPos, 1.0);
	
	float directionWeighting = max(dot(aVtxNor, uLightDirection), 0.0);
	vLightWeight = vec3(1.0, 1.0, 1.0) * directionWeighting;
}


// ====
// C:\inetpub\wwwroot\WebGL\code\benchmarker.js
// ----
function Benchmarker($benchmarker) {
    var self = {};

// ReSharper disable InconsistentNaming
    var _bins = [];
    var _sum = 0;
    var _binIndex = 0;
// ReSharper restore InconsistentNaming

    self.run = true;

    self.createBins = function (nBins) {
        for (var i = 0; i < nBins; i++) {
            _bins.push(0);
            $benchmarker.append('<div class="bin"></div>');
        }
        $benchmarker.append('<div class="bin avg">0</div>');

        $benchmarker.children('.avg').click(function () {
            self.run = !self.run;
            webgl.common.tick();
        });
    };

    self.setFrameTime = function (frameTime) {
        // recalculate mean
        if (!isNaN(frameTime)) {
            //console.log(frameTime + 1);
            _sum -= _bins[_binIndex];
            _bins[_binIndex] = frameTime;
            _sum += _bins[_binIndex];
        }

        if (_binIndex == 0)
            $benchmarker.children().eq(_bins.length).text(this.getFramesPerSec());

        // _binIndex-th bin set to frameTime
        var bin = $benchmarker.children().eq(_binIndex);
        bin.text(frameTime);
        bin.height(frameTime + 'px');

        // increment _binIndex
        _binIndex++;
        _binIndex = _binIndex % _bins.length;
    };

    self.getFramesPerSec = function () {
        var meanFrameTime = _sum / _bins.length;
        return (1000 / meanFrameTime).toFixed(0);
    };

    return self;
}


// ====
// C:\inetpub\wwwroot\WebGL\code\camera.js
// ----
function Camera() {
    this.q = quat4.create([0, 0, 0, 1]);
    this.p = vec3.create([0, 0, 0]); // this is the NEGATIVE of the camera's position - to save a negation step before translating the mvMatrix
}

Camera.prototype.advance = function (delta) {
    var zAxis = quat4.multiplyVec3(this.q, [0, 0, 1]); // use +ve axis to avoid negating camera position when translating mvMatrix
    vec3.add(this.p, vec3.scale(zAxis, delta, []));
};
Camera.prototype.bank = function (delta) {
    var zAxis = quat4.multiplyVec3(this.q, [0, 0, 1]);
    quat4.multiply(quat4.fromAngleAxis(delta, zAxis), this.q, this.q);
};
Camera.prototype.pitch = function (delta) {
    var xAxis = quat4.multiplyVec3(this.q, [1, 0, 0]);
    quat4.multiply(quat4.fromAngleAxis(delta, xAxis), this.q, this.q);
};
Camera.prototype.yaw = function (delta) {
    var yAxis = quat4.multiplyVec3(this.q, [0, 1, 0]);
    quat4.multiply(quat4.fromAngleAxis(delta, yAxis), this.q, this.q);
};
Camera.prototype.strafe = function (delta) {
    var xAxis = quat4.multiplyVec3(this.q, [-1, 0, 0]); // use -ve axis to avoid negating camera position when translating mvMatrix
    vec3.add(this.p, vec3.scale(xAxis, delta, []));
};
Camera.prototype.fly = function (delta) {
    var yAxis = quat4.multiplyVec3(this.q, [0, -1, 0]); // use -ve axis to avoid negating camera position when translating mvMatrix
    vec3.add(this.p, vec3.scale(yAxis, delta, []));
};

Camera.prototype.getFrustum = function () {
    return null;
};


// ====
// C:\inetpub\wwwroot\WebGL\code\common.js
// ----
Array.prototype.contains = function(obj) {
    var i = this.length;
    while (i--) {
        if (this[i] === obj) {
            return true;
        }
    }
    return false;
};


// ====
// C:\inetpub\wwwroot\WebGL\code\cube.js
// ----
function Cube(gl, sp, p) { // gl, shaderProgram, position

    this.getVtxPos = function() {
        return [
            -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, // Front face
            -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, // Back face
            -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, // Top face
            -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // Bottom face
            1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, // Right face
            -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1 // Left face
        ];
    };

    this.getVtxNor = function() {
        return [
            0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // Front face
            0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back face
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // Top face
            0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom face
            1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // Right face
            -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 // Left face
        ];
    };

    this.getVtxInd = function() {
        return [
            0, 1, 2, 0, 2, 3, // Front face
            4, 5, 6, 4, 6, 7, // Back face
            8, 9, 10, 8, 10, 11, // Top face
            12, 13, 14, 12, 14, 15, // Bottom face
            16, 17, 18, 16, 18, 19, // Right face
            20, 21, 22, 20, 22, 23  // Left face
        ];
    };

    var vtxPos = this.getVtxPos();
    var vtxNor = this.getVtxNor();
    var vtxInd = this.getVtxInd();

    var vtxPosBuf;
    var vtxNorBuf;
    var vtxIndBuf;

    if (gl) {
        vtxPosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxPos), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxPos']);
        vtxNorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxNor), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxNor']);
        vtxIndBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vtxInd), gl.STATIC_DRAW);
    }

    this.draw = function(cam) { // camera
        gl.useProgram(sp);

        webgl.common.pushMvMatrix();

        mat4.translate(webgl.common.mvMatrix, p); // translation by p
        //mat4.multiply(webgl.common.mvMatrix, q); // rotation by q

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.vertexAttribPointer(sp['aVtxPos'], 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.vertexAttribPointer(sp['aVtxNor'], 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(sp['uPMatrix'], false, webgl.common.pMatrix);
        gl.uniformMatrix4fv(sp['uMvMatrix'], false, webgl.common.mvMatrix);
        gl.uniform3f(sp['uLightDirection'], lightDirection[0], lightDirection[1], lightDirection[2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.drawElements(gl.TRIANGLES, vtxInd.length, gl.UNSIGNED_SHORT, 0);

        webgl.common.popMvMatrix();
    };
}


// ====
// C:\inetpub\wwwroot\WebGL\code\glMatrix-0.9.5.min.js
// ----
// glMatrix v0.9.5mdo
glMatrixArrayType = typeof Float32Array != "undefined" ? Float32Array : typeof WebGLFloatArray != "undefined" ? WebGLFloatArray : Array; var vec3 = {}; vec3.create = function (a) { var b = new glMatrixArrayType(3); if (a) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2] } return b }; vec3.set = function (a, b) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; return b }; vec3.add = function (a, b, c) { if (!c || a == c) { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; return a } c[0] = a[0] + b[0]; c[1] = a[1] + b[1]; c[2] = a[2] + b[2]; return c };
vec3.subtract = function (a, b, c) { if (!c || a == c) { a[0] -= b[0]; a[1] -= b[1]; a[2] -= b[2]; return a } c[0] = a[0] - b[0]; c[1] = a[1] - b[1]; c[2] = a[2] - b[2]; return c }; vec3.negate = function (a, b) { b || (b = a); b[0] = -a[0]; b[1] = -a[1]; b[2] = -a[2]; return b }; vec3.scale = function (a, b, c) { if (!c || a == c) { a[0] *= b; a[1] *= b; a[2] *= b; return a } c[0] = a[0] * b; c[1] = a[1] * b; c[2] = a[2] * b; return c };
vec3.normalize = function (a, b) { b || (b = a); var c = a[0], d = a[1], e = a[2], g = Math.sqrt(c * c + d * d + e * e); if (g) { if (g == 1) { b[0] = c; b[1] = d; b[2] = e; return b } } else { b[0] = 0; b[1] = 0; b[2] = 0; return b } g = 1 / g; b[0] = c * g; b[1] = d * g; b[2] = e * g; return b }; vec3.cross = function (a, b, c) { c || (c = a); var d = a[0], e = a[1]; a = a[2]; var g = b[0], f = b[1]; b = b[2]; c[0] = e * b - a * f; c[1] = a * g - d * b; c[2] = d * f - e * g; return c }; vec3.length = function (a) { var b = a[0], c = a[1]; a = a[2]; return Math.sqrt(b * b + c * c + a * a) }; vec3.dot = function (a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] };
vec3.direction = function (a, b, c) { c || (c = a); var d = a[0] - b[0], e = a[1] - b[1]; a = a[2] - b[2]; b = Math.sqrt(d * d + e * e + a * a); if (!b) { c[0] = 0; c[1] = 0; c[2] = 0; return c } b = 1 / b; c[0] = d * b; c[1] = e * b; c[2] = a * b; return c }; vec3.lerp = function (a, b, c, d) { d || (d = a); d[0] = a[0] + c * (b[0] - a[0]); d[1] = a[1] + c * (b[1] - a[1]); d[2] = a[2] + c * (b[2] - a[2]); return d }; vec3.str = function (a) { return "[" + a[0] + ", " + a[1] + ", " + a[2] + "]" }; var mat3 = {};
mat3.create = function (a) { var b = new glMatrixArrayType(9); if (a) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9] } return b }; mat3.set = function (a, b) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; return b }; mat3.identity = function (a) { a[0] = 1; a[1] = 0; a[2] = 0; a[3] = 0; a[4] = 1; a[5] = 0; a[6] = 0; a[7] = 0; a[8] = 1; return a };
mat3.transpose = function (a, b) { if (!b || a == b) { var c = a[1], d = a[2], e = a[5]; a[1] = a[3]; a[2] = a[6]; a[3] = c; a[5] = a[7]; a[6] = d; a[7] = e; return a } b[0] = a[0]; b[1] = a[3]; b[2] = a[6]; b[3] = a[1]; b[4] = a[4]; b[5] = a[7]; b[6] = a[2]; b[7] = a[5]; b[8] = a[8]; return b }; mat3.toMat4 = function (a, b) { b || (b = mat4.create()); b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = 0; b[4] = a[3]; b[5] = a[4]; b[6] = a[5]; b[7] = 0; b[8] = a[6]; b[9] = a[7]; b[10] = a[8]; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return b };
mat3.str = function (a) { return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + "]" }; var mat4 = {}; mat4.create = function (a) { var b = new glMatrixArrayType(16); if (a) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; b[15] = a[15] } return b };
mat4.set = function (a, b) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; b[15] = a[15]; return b }; mat4.identity = function (a) { a[0] = 1; a[1] = 0; a[2] = 0; a[3] = 0; a[4] = 0; a[5] = 1; a[6] = 0; a[7] = 0; a[8] = 0; a[9] = 0; a[10] = 1; a[11] = 0; a[12] = 0; a[13] = 0; a[14] = 0; a[15] = 1; return a };
mat4.transpose = function (a, b) { if (!b || a == b) { var c = a[1], d = a[2], e = a[3], g = a[6], f = a[7], h = a[11]; a[1] = a[4]; a[2] = a[8]; a[3] = a[12]; a[4] = c; a[6] = a[9]; a[7] = a[13]; a[8] = d; a[9] = g; a[11] = a[14]; a[12] = e; a[13] = f; a[14] = h; return a } b[0] = a[0]; b[1] = a[4]; b[2] = a[8]; b[3] = a[12]; b[4] = a[1]; b[5] = a[5]; b[6] = a[9]; b[7] = a[13]; b[8] = a[2]; b[9] = a[6]; b[10] = a[10]; b[11] = a[14]; b[12] = a[3]; b[13] = a[7]; b[14] = a[11]; b[15] = a[15]; return b };
mat4.determinant = function (a) { var b = a[0], c = a[1], d = a[2], e = a[3], g = a[4], f = a[5], h = a[6], i = a[7], j = a[8], k = a[9], l = a[10], o = a[11], m = a[12], n = a[13], p = a[14]; a = a[15]; return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a };
mat4.inverse = function (a, b) {
    b || (b = a); var c = a[0], d = a[1], e = a[2], g = a[3], f = a[4], h = a[5], i = a[6], j = a[7], k = a[8], l = a[9], o = a[10], m = a[11], n = a[12], p = a[13], r = a[14], s = a[15], A = c * h - d * f, B = c * i - e * f, t = c * j - g * f, u = d * i - e * h, v = d * j - g * h, w = e * j - g * i, x = k * p - l * n, y = k * r - o * n, z = k * s - m * n, C = l * r - o * p, D = l * s - m * p, E = o * s - m * r, q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x); b[0] = (h * E - i * D + j * C) * q; b[1] = (-d * E + e * D - g * C) * q; b[2] = (p * w - r * v + s * u) * q; b[3] = (-l * w + o * v - m * u) * q; b[4] = (-f * E + i * z - j * y) * q; b[5] = (c * E - e * z + g * y) * q; b[6] = (-n * w + r * t - s * B) * q; b[7] = (k * w - o * t + m * B) * q; b[8] = (f * D - h * z + j * x) * q;
    b[9] = (-c * D + d * z - g * x) * q; b[10] = (n * v - p * t + s * A) * q; b[11] = (-k * v + l * t - m * A) * q; b[12] = (-f * C + h * y - i * x) * q; b[13] = (c * C - d * y + e * x) * q; b[14] = (-n * u + p * B - r * A) * q; b[15] = (k * u - l * B + o * A) * q; return b
}; mat4.toRotationMat = function (a, b) { b || (b = mat4.create()); b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return b };
mat4.toMat3 = function (a, b) { b || (b = mat3.create()); b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[4]; b[4] = a[5]; b[5] = a[6]; b[6] = a[8]; b[7] = a[9]; b[8] = a[10]; return b }; mat4.toInverseMat3 = function (a, b) { var c = a[0], d = a[1], e = a[2], g = a[4], f = a[5], h = a[6], i = a[8], j = a[9], k = a[10], l = k * f - h * j, o = -k * g + h * i, m = j * g - f * i, n = c * l + d * o + e * m; if (!n) return null; n = 1 / n; b || (b = mat3.create()); b[0] = l * n; b[1] = (-k * d + e * j) * n; b[2] = (h * d - e * f) * n; b[3] = o * n; b[4] = (k * c - e * i) * n; b[5] = (-h * c + e * g) * n; b[6] = m * n; b[7] = (-j * c + d * i) * n; b[8] = (f * c - d * g) * n; return b };
mat4.multiply = function (a, b, c) {
    c || (c = a); var d = a[0], e = a[1], g = a[2], f = a[3], h = a[4], i = a[5], j = a[6], k = a[7], l = a[8], o = a[9], m = a[10], n = a[11], p = a[12], r = a[13], s = a[14]; a = a[15]; var A = b[0], B = b[1], t = b[2], u = b[3], v = b[4], w = b[5], x = b[6], y = b[7], z = b[8], C = b[9], D = b[10], E = b[11], q = b[12], F = b[13], G = b[14]; b = b[15]; c[0] = A * d + B * h + t * l + u * p; c[1] = A * e + B * i + t * o + u * r; c[2] = A * g + B * j + t * m + u * s; c[3] = A * f + B * k + t * n + u * a; c[4] = v * d + w * h + x * l + y * p; c[5] = v * e + w * i + x * o + y * r; c[6] = v * g + w * j + x * m + y * s; c[7] = v * f + w * k + x * n + y * a; c[8] = z * d + C * h + D * l + E * p; c[9] = z * e + C * i + D * o + E * r; c[10] = z *
g + C * j + D * m + E * s; c[11] = z * f + C * k + D * n + E * a; c[12] = q * d + F * h + G * l + b * p; c[13] = q * e + F * i + G * o + b * r; c[14] = q * g + F * j + G * m + b * s; c[15] = q * f + F * k + G * n + b * a; return c
}; mat4.multiplyVec3 = function (a, b, c) { c || (c = b); var d = b[0], e = b[1]; b = b[2]; c[0] = a[0] * d + a[4] * e + a[8] * b + a[12]; c[1] = a[1] * d + a[5] * e + a[9] * b + a[13]; c[2] = a[2] * d + a[6] * e + a[10] * b + a[14]; return c };
mat4.multiplyVec4 = function (a, b, c) { c || (c = b); var d = b[0], e = b[1], g = b[2]; b = b[3]; c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b; c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b; c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b; c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b; return c };
mat4.translate = function (a, b, c) { var d = b[0], e = b[1]; b = b[2]; if (!c || a == c) { a[12] = a[0] * d + a[4] * e + a[8] * b + a[12]; a[13] = a[1] * d + a[5] * e + a[9] * b + a[13]; a[14] = a[2] * d + a[6] * e + a[10] * b + a[14]; a[15] = a[3] * d + a[7] * e + a[11] * b + a[15]; return a } var g = a[0], f = a[1], h = a[2], i = a[3], j = a[4], k = a[5], l = a[6], o = a[7], m = a[8], n = a[9], p = a[10], r = a[11]; c[0] = g; c[1] = f; c[2] = h; c[3] = i; c[4] = j; c[5] = k; c[6] = l; c[7] = o; c[8] = m; c[9] = n; c[10] = p; c[11] = r; c[12] = g * d + j * e + m * b + a[12]; c[13] = f * d + k * e + n * b + a[13]; c[14] = h * d + l * e + p * b + a[14]; c[15] = i * d + o * e + r * b + a[15]; return c };
mat4.scale = function (a, b, c) { var d = b[0], e = b[1]; b = b[2]; if (!c || a == c) { a[0] *= d; a[1] *= d; a[2] *= d; a[3] *= d; a[4] *= e; a[5] *= e; a[6] *= e; a[7] *= e; a[8] *= b; a[9] *= b; a[10] *= b; a[11] *= b; return a } c[0] = a[0] * d; c[1] = a[1] * d; c[2] = a[2] * d; c[3] = a[3] * d; c[4] = a[4] * e; c[5] = a[5] * e; c[6] = a[6] * e; c[7] = a[7] * e; c[8] = a[8] * b; c[9] = a[9] * b; c[10] = a[10] * b; c[11] = a[11] * b; c[12] = a[12]; c[13] = a[13]; c[14] = a[14]; c[15] = a[15]; return c };
mat4.rotate = function (a, b, c, d) {
    var e = c[0], g = c[1]; c = c[2]; var f = Math.sqrt(e * e + g * g + c * c); if (!f) return null; if (f != 1) { f = 1 / f; e *= f; g *= f; c *= f } var h = Math.sin(b), i = Math.cos(b), j = 1 - i; b = a[0]; f = a[1]; var k = a[2], l = a[3], o = a[4], m = a[5], n = a[6], p = a[7], r = a[8], s = a[9], A = a[10], B = a[11], t = e * e * j + i, u = g * e * j + c * h, v = c * e * j - g * h, w = e * g * j - c * h, x = g * g * j + i, y = c * g * j + e * h, z = e * c * j + g * h; e = g * c * j - e * h; g = c * c * j + i; if (d) { if (a != d) { d[12] = a[12]; d[13] = a[13]; d[14] = a[14]; d[15] = a[15] } } else d = a; d[0] = b * t + o * u + r * v; d[1] = f * t + m * u + s * v; d[2] = k * t + n * u + A * v; d[3] = l * t + p * u + B *
v; d[4] = b * w + o * x + r * y; d[5] = f * w + m * x + s * y; d[6] = k * w + n * x + A * y; d[7] = l * w + p * x + B * y; d[8] = b * z + o * e + r * g; d[9] = f * z + m * e + s * g; d[10] = k * z + n * e + A * g; d[11] = l * z + p * e + B * g; return d
}; mat4.rotateX = function (a, b, c) { var d = Math.sin(b); b = Math.cos(b); var e = a[4], g = a[5], f = a[6], h = a[7], i = a[8], j = a[9], k = a[10], l = a[11]; if (c) { if (a != c) { c[0] = a[0]; c[1] = a[1]; c[2] = a[2]; c[3] = a[3]; c[12] = a[12]; c[13] = a[13]; c[14] = a[14]; c[15] = a[15] } } else c = a; c[4] = e * b + i * d; c[5] = g * b + j * d; c[6] = f * b + k * d; c[7] = h * b + l * d; c[8] = e * -d + i * b; c[9] = g * -d + j * b; c[10] = f * -d + k * b; c[11] = h * -d + l * b; return c };
mat4.rotateY = function (a, b, c) { var d = Math.sin(b); b = Math.cos(b); var e = a[0], g = a[1], f = a[2], h = a[3], i = a[8], j = a[9], k = a[10], l = a[11]; if (c) { if (a != c) { c[4] = a[4]; c[5] = a[5]; c[6] = a[6]; c[7] = a[7]; c[12] = a[12]; c[13] = a[13]; c[14] = a[14]; c[15] = a[15] } } else c = a; c[0] = e * b + i * -d; c[1] = g * b + j * -d; c[2] = f * b + k * -d; c[3] = h * b + l * -d; c[8] = e * d + i * b; c[9] = g * d + j * b; c[10] = f * d + k * b; c[11] = h * d + l * b; return c };
mat4.rotateZ = function (a, b, c) { var d = Math.sin(b); b = Math.cos(b); var e = a[0], g = a[1], f = a[2], h = a[3], i = a[4], j = a[5], k = a[6], l = a[7]; if (c) { if (a != c) { c[8] = a[8]; c[9] = a[9]; c[10] = a[10]; c[11] = a[11]; c[12] = a[12]; c[13] = a[13]; c[14] = a[14]; c[15] = a[15] } } else c = a; c[0] = e * b + i * d; c[1] = g * b + j * d; c[2] = f * b + k * d; c[3] = h * b + l * d; c[4] = e * -d + i * b; c[5] = g * -d + j * b; c[6] = f * -d + k * b; c[7] = h * -d + l * b; return c };
mat4.frustum = function (a, b, c, d, e, g, f) { f || (f = mat4.create()); var h = b - a, i = d - c, j = g - e; f[0] = e * 2 / h; f[1] = 0; f[2] = 0; f[3] = 0; f[4] = 0; f[5] = e * 2 / i; f[6] = 0; f[7] = 0; f[8] = (b + a) / h; f[9] = (d + c) / i; f[10] = -(g + e) / j; f[11] = -1; f[12] = 0; f[13] = 0; f[14] = -(g * e * 2) / j; f[15] = 0; return f }; mat4.perspective = function (a, b, c, d, e) { a = c * Math.tan(a * Math.PI / 360); b = a * b; return mat4.frustum(-b, b, -a, a, c, d, e) };
mat4.ortho = function (a, b, c, d, e, g, f) { f || (f = mat4.create()); var h = b - a, i = d - c, j = g - e; f[0] = 2 / h; f[1] = 0; f[2] = 0; f[3] = 0; f[4] = 0; f[5] = 2 / i; f[6] = 0; f[7] = 0; f[8] = 0; f[9] = 0; f[10] = -2 / j; f[11] = 0; f[12] = -(a + b) / h; f[13] = -(d + c) / i; f[14] = -(g + e) / j; f[15] = 1; return f };
mat4.lookAt = function (a, b, c, d) {
    d || (d = mat4.create()); var e = a[0], g = a[1]; a = a[2]; var f = c[0], h = c[1], i = c[2]; c = b[1]; var j = b[2]; if (e == b[0] && g == c && a == j) return mat4.identity(d); var k, l, o, m; c = e - b[0]; j = g - b[1]; b = a - b[2]; m = 1 / Math.sqrt(c * c + j * j + b * b); c *= m; j *= m; b *= m; k = h * b - i * j; i = i * c - f * b; f = f * j - h * c; if (m = Math.sqrt(k * k + i * i + f * f)) { m = 1 / m; k *= m; i *= m; f *= m } else f = i = k = 0; h = j * f - b * i; l = b * k - c * f; o = c * i - j * k; if (m = Math.sqrt(h * h + l * l + o * o)) { m = 1 / m; h *= m; l *= m; o *= m } else o = l = h = 0; d[0] = k; d[1] = h; d[2] = c; d[3] = 0; d[4] = i; d[5] = l; d[6] = j; d[7] = 0; d[8] = f; d[9] =
o; d[10] = b; d[11] = 0; d[12] = -(k * e + i * g + f * a); d[13] = -(h * e + l * g + o * a); d[14] = -(c * e + j * g + b * a); d[15] = 1; return d
}; mat4.str = function (a) { return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ",  " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ",  " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ",  " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + "]" }; quat4 = {}; quat4.create = function (a) { var b = new glMatrixArrayType(4); if (a) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3] } return b }; quat4.set = function (a, b) { b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; return b };
quat4.calculateW = function (a, b) { var c = a[0], d = a[1], e = a[2]; if (!b || a == b) { a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e)); return a } b[0] = c; b[1] = d; b[2] = e; b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e)); return b }; quat4.inverse = function (a, b) { if (!b || a == b) { a[0] *= 1; a[1] *= 1; a[2] *= 1; return a } b[0] = -a[0]; b[1] = -a[1]; b[2] = -a[2]; b[3] = a[3]; return b }; quat4.length = function (a) { var b = a[0], c = a[1], d = a[2]; a = a[3]; return Math.sqrt(b * b + c * c + d * d + a * a) };
quat4.normalize = function (a, b) { b || (b = a); var c = a[0], d = a[1], e = a[2], g = a[3], f = Math.sqrt(c * c + d * d + e * e + g * g); if (f == 0) { b[0] = 0; b[1] = 0; b[2] = 0; b[3] = 0; return b } f = 1 / f; b[0] = c * f; b[1] = d * f; b[2] = e * f; b[3] = g * f; return b }; quat4.multiply = function (a, b, c) { c || (c = a); var d = a[0], e = a[1], g = a[2]; a = a[3]; var f = b[0], h = b[1], i = b[2]; b = b[3]; c[0] = d * b + a * f + e * i - g * h; c[1] = e * b + a * h + g * f - d * i; c[2] = g * b + a * i + d * h - e * f; c[3] = a * b - d * f - e * h - g * i; return c };
quat4.multiplyVec3 = function (a, b, c) { c || (c = b); var d = b[0], e = b[1], g = b[2]; b = a[0]; var f = a[1], h = a[2]; a = a[3]; var i = a * d + f * g - h * e, j = a * e + h * d - b * g, k = a * g + b * e - f * d; d = -b * d - f * e - h * g; c[0] = i * a + d * -b + j * -h - k * -f; c[1] = j * a + d * -f + k * -b - i * -h; c[2] = k * a + d * -h + i * -f - j * -b; return c }; quat4.toMat3 = function (a, b) { b || (b = mat3.create()); var c = a[0], d = a[1], e = a[2], g = a[3], f = c + c, h = d + d, i = e + e, j = c * f, k = c * h; c = c * i; var l = d * h; d = d * i; e = e * i; f = g * f; h = g * h; g = g * i; b[0] = 1 - (l + e); b[1] = k - g; b[2] = c + h; b[3] = k + g; b[4] = 1 - (j + e); b[5] = d - f; b[6] = c - h; b[7] = d + f; b[8] = 1 - (j + l); return b };
quat4.toMat4 = function (a, b) { b || (b = mat4.create()); var c = a[0], d = a[1], e = a[2], g = a[3], f = c + c, h = d + d, i = e + e, j = c * f, k = c * h; c = c * i; var l = d * h; d = d * i; e = e * i; f = g * f; h = g * h; g = g * i; b[0] = 1 - (l + e); b[1] = k - g; b[2] = c + h; b[3] = 0; b[4] = k + g; b[5] = 1 - (j + e); b[6] = d - f; b[7] = 0; b[8] = c - h; b[9] = d + f; b[10] = 1 - (j + l); b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return b }; quat4.slerp = function (a, b, c, d) { d || (d = a); var e = c; if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c; d[0] = 1 - c * a[0] + e * b[0]; d[1] = 1 - c * a[1] + e * b[1]; d[2] = 1 - c * a[2] + e * b[2]; d[3] = 1 - c * a[3] + e * b[3]; return d };
quat4.str = function (a) { return "[" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + "]" };

var vec2 = {}; vec2.create = function (a) { var b = new glMatrixArrayType(2); if (a) { b[0] = a[0]; b[1] = a[1]; } return b }; vec2.dot = function (a, b) { return a[0] * b[0] + a[1] * b[1] };

vec3.str = function (a, b) { return "[" + a[0].toFixed(b) + ", " + a[1].toFixed(b) + ", " + a[2].toFixed(b) + "]"; };
mat4.str = function (a, b) { return "[" + a[0].toFixed(b) + ", " + a[1].toFixed(b) + ", " + a[2].toFixed(b) + ", " + a[3].toFixed(b) + ",  " + a[4].toFixed(b) + ", " + a[5].toFixed(b) + ", " + a[6].toFixed(b) + ", " + a[7].toFixed(b) + ",  " + a[8].toFixed(b) + ", " + a[9].toFixed(b) + ", " + a[10].toFixed(b) + ", " + a[11].toFixed(b) + ",  " + a[12].toFixed(b) + ", " + a[13].toFixed(b) + ", " + a[14].toFixed(b) + ", " + a[15].toFixed(b) + "]" };
mat3.str = function (a, b) { return "[" + a[0].toFixed(b) + ", " + a[1].toFixed(b) + ", " + a[2].toFixed(b) + ",  " + a[3].toFixed(b) + ", " + a[4].toFixed(b) + ", " + a[5].toFixed(b) + ",  " + a[6].toFixed(b) + ", " + a[7].toFixed(b) + ", " + a[8].toFixed(b) + "]" };
quat4.str = function (a, b) { return "[" + a[0].toFixed(b) + ", " + a[1].toFixed(b) + ", " + a[2].toFixed(b) + ", " + a[3].toFixed(b) + "]" };
vec3.areEqual = function (a, b) { return a[0] == b[0] && a[1] == b[1] && a[2] == b[2]; };
quat4.fromAngleAxis = function (angle, axis, dest) { if (!dest) dest = quat4.create(); var half = angle * 0.5; var s = Math.sin(half); dest[3] = Math.cos(half); dest[0] = s * axis[0]; dest[1] = s * axis[1]; dest[2] = s * axis[2]; return dest; };


// ====
// C:\inetpub\wwwroot\WebGL\code\grid.js
// ----
function Grid(gl, sp, p, side) { // gl, shaderProgram, position, side
    var vtxPos = [];
    var vtxNor = [];
    var vtxInd = [];

    var i = 0;
    for (var x = 0; x < side; x++) {
        for (var z = 0; z < side; z++) {
            var index = z + side * x;
            vtxPos[3 * index] = x - side / 2;
            vtxPos[3 * index + 1] = -1;
            vtxPos[3 * index + 2] = -z;

            vtxNor[3 * index] = 0;
            vtxNor[3 * index + 1] = 1;
            vtxNor[3 * index + 2] = 0;

            if (x > 0 && z > 0) {
                vtxInd.push(index - 1);
                vtxInd.push(index);
                vtxInd.push(index - side);
            }
        }
    }

    var vtxPosBuf;
    var vtxNorBuf;
    var vtxIndBuf;

    if (gl) {
        vtxPosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxPos), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxPos']);
        vtxNorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxNor), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxNor']);
        vtxIndBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vtxInd), gl.STATIC_DRAW);
    }

    this.draw = function(cam) { // camera
        gl.useProgram(sp);

        webgl.common.pushMvMatrix();

        mat4.translate(webgl.common.mvMatrix, p); // translation by p
        //mat4.multiply(webgl.common.mvMatrix, q); // rotation by q

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.vertexAttribPointer(sp['aVtxPos'], 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.vertexAttribPointer(sp['aVtxNor'], 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(sp['uPMatrix'], false, webgl.common.pMatrix);
        gl.uniformMatrix4fv(sp['uMvMatrix'], false, webgl.common.mvMatrix);
        gl.uniform3f(sp['uLightDirection'], lightDirection[0], lightDirection[1], lightDirection[2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.drawElements(gl.TRIANGLES, vtxInd.length, gl.UNSIGNED_SHORT, 0);

        webgl.common.popMvMatrix();
    };
}

// ====
// C:\inetpub\wwwroot\WebGL\code\index.html
// ----
<!--

    TODO:
    terrain with default heightmap
    terrain as sphere
    terrain as sphere with noise
    skydome
    atmosphere
    collision detection

    -->

<html>
    <head>
        <title>WebGL</title>
        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"/>

        <script type="text/javascript" src="jquery-1.4.4.min.js"></script>
        <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="webgl-utils.js"></script>
        <script type="text/javascript" src="common.js"></script>
        <script type="text/javascript" src="benchmarker.js"></script>
        <script type="text/javascript" src="webgl.js"></script>
        <script type="text/javascript" src="shaderProgram.js"></script>
        <script type="text/javascript" src="camera.js"></script>
        <script type="text/javascript" src="keyboard.js"></script>
        <script type="text/javascript" src="square.js"></script>
        <script type="text/javascript" src="cube.js"></script>
        <script type="text/javascript" src="sphere.js"></script>
        <script type="text/javascript" src="grid.js"></script>
        <script type="text/javascript" src="simplex.js"></script>
        <script type="text/javascript" src="node.js"></script>
        <script type="text/javascript" src="terrain.js"></script>

        <script type="text/javascript">
            var lightDirection = vec3.create([0.1, 0.4, 0.8]);

            //    // lesson 1 - starting
            //    // lesson 2 - color
            //    // lesson 3 - animation
            //    // lesson 4 - 3D
            //    // lesson 5 - textures
            //    // lesson 6 - mip mapping textures
            //    // 7 - lighting
            //    // 8 - transparency
            //    // 9 - many objects
            //    // 10 - doom
            //    // 11 - sphere + lighting + mouse
            //    // 12 - light from point
            //    // 13 - per pixel light from point
            //    // 14 - teapot
            //    // 15 - specular globe
            //    // 16 - frame buffer
        </script>

        <style type="text/css">
            body { margin:0; padding:0; background:#333; }
            #benchmarker { border:1px solid white; height:40px; position:absolute; top:0; opacity:0.3; }
            #benchmarker .bin { background-color:grey; float:left; width:30px; height:0px; border:1px solid black; text-align:center; }
            #benchmarker .bin.avg { height:38px; }
        </style>
    </head>

    <body>

        <canvas id="canvas" width="1200" height="400"></canvas>

        <div id="benchmarker"></div>

        <script type="text/javascript">
            var canvas = document.getElementById('canvas');
            var $benchmarker = $('#benchmarker');
            webgl.common.init(canvas, $benchmarker);
        </script>

    </body>
</html>


// ====
// C:\inetpub\wwwroot\WebGL\code\jquery-1.4.4.min.js
// ----
/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);


// ====
// C:\inetpub\wwwroot\WebGL\code\keyboard.js
// ----
var webgl = webgl || {};

var currentlyPressedKeys = {};
var keyboard = {};
keyboard.scale = 0.5;

function handleKeyDown(event) {
    //console.log(event.keyCode);
    currentlyPressedKeys[event.keyCode] = true;
}

function handleKeyUp(event) {
    currentlyPressedKeys[event.keyCode] = false;
}

function handleKeys() {
    // left arrow = 37
    // right arrow = 39
    // up arrow = 38
    // down arrow = 40
    // alt / option (both) = 18
    // ctrl = 17
    // shift (both) = 16
    // command = 224
    // w = 87, a = 65,s = 83,d = 68
    if (currentlyPressedKeys[38]) {
        if (currentlyPressedKeys[16]) webgl.common.cam.fly(keyboard.scale * 1);
        else webgl.common.cam.advance(keyboard.scale * 1);
    }
    if (currentlyPressedKeys[40]) {
        if (currentlyPressedKeys[16]) webgl.common.cam.fly(keyboard.scale * -1);
        else webgl.common.cam.advance(keyboard.scale * -1);
    }
    if (currentlyPressedKeys[37]) {
        if (currentlyPressedKeys[16]) webgl.common.cam.strafe(keyboard.scale * -1);
        else webgl.common.cam.yaw(keyboard.scale * 0.03);
    }
    if (currentlyPressedKeys[39]) {
        if (currentlyPressedKeys[16]) webgl.common.cam.strafe(keyboard.scale * 1);
        else webgl.common.cam.yaw(keyboard.scale * -0.03);
    }
    if (currentlyPressedKeys[87]) webgl.common.cam.pitch(keyboard.scale * 0.03);
    if (currentlyPressedKeys[83]) webgl.common.cam.pitch(keyboard.scale * -0.03);
    if (currentlyPressedKeys[65]) webgl.common.cam.bank(keyboard.scale * 0.03);
    if (currentlyPressedKeys[68]) webgl.common.cam.bank(keyboard.scale * -0.03);
}


// ====
// C:\inetpub\wwwroot\WebGL\code\node.js
// ----
function Node(index, heightmap, terrain) {
    var self = {};

    function getCentre() {
        return vec3.add(Node.getCentre(index), terrain.getP(), []);
    };

    function getBufferIndex() {
        return '' + 0;
    };

    function isFrustumCulled(cam) {
        return false;
    }

    var _centre = getCentre();
    var _size = Node.getSize(index);
    var _bufferIndex = getBufferIndex();
    var _splitOrMerge = 0;

    self.draw = function (cam) { // camera
        if (isFrustumCulled(cam))
            return [];

        _splitOrMerge = self.getSplitOrMerge(cam);

        if (_splitOrMerge === Node.splitOrMerge.SPLIT) {
            split(); // note: this will add children to (and remove the current node from) the store...
            return draw(cam, [true, true, true, true]); // ... but the children won't be drawn in this frame, so draw the current node one last time
        } else if (_splitOrMerge === Node.splitOrMerge.MERGE) {
            var merged = merge(cam);
            if (merged) // note: if all siblings want to merge, we'll remove them and add the parent...
                return terrain.nodes[Node.getParentIndex(index)].draw(cam); // ... but the parent won't be looped over, so manually draw it
            else
                return draw(cam); // if any sibling doesn't want to merge, we need to draw each sibling separately
        } else {
            return draw(cam);
        }
    };

    self.getSplitOrMerge = function (cam) {
        // if already processed, return value...
        if (terrain.processed.contains(index))
            return _splitOrMerge;

        // ... otherwise, calculate...
        var centreToCam = vec3.add(_centre, cam.p, []); // note: add, because cam.p is negative
        var distSq = vec3.dot(centreToCam, centreToCam); // don't waste time square-rooting
        var sizeSq = _size * _size;
        _splitOrMerge = Node.splitOrMerge.NONE;
        if (distSq < sizeSq * Node.splitScaling) {
            _splitOrMerge = Node.getLevel(index) < 6 ? Node.splitOrMerge.SPLIT : Node.splitOrMerge.NONE;
        } else if (distSq > 2 * sizeSq * Node.splitScaling) {
            _splitOrMerge = Node.splitOrMerge.MERGE;
        }
        // ... flag as processed...
        terrain.processed.push(index);
        // ... and return value
        return _splitOrMerge;
    };

    function split() {
        // add children
        var childIndexes = Node.getChildIndexes(index);
        childIndexes.forEach(function (i) {
            terrain.nodes[i] = new Node(i, heightmap, terrain);
        });
        // TODO: remove self / parent / grandparent? look at memory usage...
    }

    function merge(cam) {
        var siblingIndexes = Node.getSiblingIndexes(index);
        var allSiblingsMerge = true;
        siblingIndexes.every(function (i) {
            if (i === index)
                return true; // note: siblings includes self
            if (!(i in terrain.nodes))
                throw 'sibling index is not stored'; // does this ever happen?
            var sibling = terrain.nodes['' + i];
            if (!sibling)
                throw 'sibling is null'; // does this ever happen?
            if (sibling.getSplitOrMerge(cam) != Node.splitOrMerge.MERGE) {
                allSiblingsMerge = false;
                return false; // note: break out of the 'every' loop
            }
            return true;
        });
        if (!allSiblingsMerge)
            return false;
        var parentIndex = Node.getParentIndex(index);
        terrain.nodes['' + parentIndex] = new Node(parentIndex, heightmap, terrain); // with _splitOrMerge set to NONE?
        siblingIndexes.forEach(function(i) {
            delete terrain.nodes['' + i];
        });
        return true;
    }

    function draw(cam, neighbourSplits) {
        // note: allow neighbourSplits to be passed in, because when a node is split, its children won't initially draw themselves
        // so, on that last frame, specify that all neighbours are split
        if (!neighbourSplits) {
            neighbourSplits = [];
            var neighbourIndexes = Node.getNeighbourIndexes(index);
            neighbourIndexes.forEach(function(i) {
                if (!(i in terrain.nodes)) {
                    neighbourSplits.push(false); // if neighbour not stored, can't be split / must be merged (TODO: check always true)
                } else {
                    var neighbour = terrain.nodes[i];
                    if (!neighbour)
                        throw 'neighbour is null'; // does this ever happen?
                    neighbourSplits.push(neighbour.getSplitOrMerge(cam) === Node.splitOrMerge.SPLIT);
                }
            });
        }
        var indexes = Node.getIndexes(index, neighbourSplits);
        return indexes;
    }

    return self;
}

Node.splitOrMerge = { SPLIT: 1, NONE: 0, MERGE: -1 };

Node.neighbour = { NORTH: 0, SOUTH: 1, EAST: 2, WEST: 3 };

Node.splitScaling = 1; // scale the point at which nodes split / merge

Node.getLevel = function (index) {
    return Math.floor(Math.log(3 * index + 1) / Math.log(4));
};

Node.getFirstIndexOfLevel = function (level) {
    return (Math.pow(4, level) - 1) / 3;
};

Node.getXY = function (index, level, firstIndexOfLevel) {
    if (!level)
        level = Node.getLevel(index);
    if (!firstIndexOfLevel)
        firstIndexOfLevel = Node.getFirstIndexOfLevel(level);

    var side = Math.pow(2, level);
    var x = ((index - firstIndexOfLevel) % side) / side;
    var y = Math.floor((index - firstIndexOfLevel) / side) / side;
    return { x: x, y: y };
};

Node.getChildIndexes = function (index, level) {
    if (!level)
        level = Node.getLevel(index);

    var xy = Node.getXY(index, level);
    var childSide = Math.pow(2, level + 1);
    var firstChildIndex = Node.getFirstIndexOfLevel(level + 1) + xy.x * childSide + xy.y * childSide * childSide;
    return [firstChildIndex, firstChildIndex + 1, firstChildIndex + childSide, firstChildIndex + childSide + 1];
};

Node.getParentIndex = function (index) {
    var level = Node.getLevel(index);
    var xy = Node.getXY(index, level);
    var parentSide = Math.pow(2, level - 1);
    return Node.getFirstIndexOfLevel(level - 1) + Math.floor(xy.x * parentSide) + Math.floor(xy.y * parentSide) * parentSide;
};

Node.getSiblingIndexes = function (index) { // note: siblings includes self
    var parentIndex = Node.getParentIndex(index);
    return Node.getChildIndexes(parentIndex);
};

Node.getNeighbourIndexes = function (index) { // convention is N, S, E, W
    var level = Node.getLevel(index);
    var firstIndexOfLevel = Node.getFirstIndexOfLevel(level);
    var side = Math.pow(2, level);
    var indexWithinLevel = index - firstIndexOfLevel;

    var neighbourIndexes = [];
    var neighbourIndex;

    // TODO: benchmark / optimize the below implementation
    // north...
    neighbourIndex = index - side;
    if (Node.getLevel(neighbourIndex) != level)
        neighbourIndex = 2 * firstIndexOfLevel + side - 1 - index;
    neighbourIndexes.push(neighbourIndex);

    // south...
    neighbourIndex = index + side;
    if (Node.getLevel(neighbourIndex) != level)
        neighbourIndex = 2 * (firstIndexOfLevel + side * (side - 0.5)) - 1 - index;
    neighbourIndexes.push(neighbourIndex);

    // east...
    neighbourIndex = index + 1;
    if ((indexWithinLevel + 1) % side == 0)
        neighbourIndex = 2 * (firstIndexOfLevel - 1) + side * (side + 1) - index;
    neighbourIndexes.push(neighbourIndex);

    // west...
    neighbourIndex = index - 1;
    if (indexWithinLevel % side == 0)
        neighbourIndex = 2 * firstIndexOfLevel + side * (side - 1) - index;
    neighbourIndexes.push(neighbourIndex);

    return neighbourIndexes;
};

Node.getIndexes = function (index, neighbourSplits) {
    var level = Node.getLevel(index);
    var xy = Node.getXY(index, level);
    var centreOffset = Math.pow(2, -level - 1);

    var indexes = [];
    var centreIndex = 129 * 128 * (xy.y + centreOffset) + 128 * (xy.x + centreOffset);
    var nwIndex = 129 * 128 * xy.y + 128 * xy.x;
    var neIndex = 129 * 128 * xy.y + 128 * (xy.x + 2 * centreOffset);
    var swIndex = 129 * 128 * (xy.y + 2 * centreOffset) + 128 * xy.x;
    var seIndex = 129 * 128 * (xy.y + 2 * centreOffset) + 128 * (xy.x + 2 * centreOffset);
    // north...
    if (neighbourSplits[Node.neighbour.NORTH]) {
        var nIndex = (nwIndex + neIndex) / 2;
        indexes.push(centreIndex, nwIndex, nIndex, centreIndex, nIndex, neIndex);
    } else {
        indexes.push(centreIndex, nwIndex, neIndex);
    }

    // east...
    if (neighbourSplits[Node.neighbour.EAST]) {
        var eIndex = (neIndex + seIndex) / 2;
        indexes.push(centreIndex, neIndex, eIndex, centreIndex, eIndex, seIndex);
    } else {
        indexes.push(centreIndex, neIndex, seIndex);
    }

    // south...
    if (neighbourSplits[Node.neighbour.SOUTH]) {
        var sIndex = (swIndex + seIndex) / 2;
        indexes.push(centreIndex, seIndex, sIndex, centreIndex, sIndex, swIndex);
    } else {
        indexes.push(centreIndex, seIndex, swIndex);
    }

    // west...
    if (neighbourSplits[Node.neighbour.WEST]) {
        var wIndex = (nwIndex + swIndex) / 2;
        indexes.push(centreIndex, swIndex, wIndex, centreIndex, wIndex, nwIndex);
    } else {
        indexes.push(centreIndex, swIndex, nwIndex);
    }
    return indexes;
};

Node.getSize = function (index, level) {
    if (!level)
        level = Node.getLevel(index);

    return Math.pow(2, 7 - level);
};

Node.getCentre = function (index) {
    var xy = Node.getXY(index);
    var size = Node.getSize(index);
    var x = xy.x * 128 + size / 2;
    var y = xy.y * 128 + size / 2;
    return vec3.create([x, 0, y]);
};


// ====
// C:\inetpub\wwwroot\WebGL\code\qunit.css
// ----
/**
* QUnit - A JavaScript Unit Testing Framework
*
* http://docs.jquery.com/QUnit
*
* Copyright (c) 2011 John Resig, J�rn Zaefferer
* Dual licensed under the MIT (MIT-LICENSE.txt)
* or GPL (GPL-LICENSE.txt) licenses.
*/

/** Font Family and Sizes */

#qunit-tests, #qunit-header, #qunit-banner, #qunit-testrunner-toolbar, #qunit-userAgent, #qunit-testresult {
font-family: "Helvetica Neue Light", "HelveticaNeue-Light", "Helvetica Neue", Calibri, Helvetica, Arial, sans-serif;
}

#qunit-testrunner-toolbar, #qunit-userAgent, #qunit-testresult, #qunit-tests li { font-size: small; }
#qunit-tests { font-size: smaller; }


/** Resets */

#qunit-tests, #qunit-tests ol, #qunit-header, #qunit-banner, #qunit-userAgent, #qunit-testresult {
margin: 0;
padding: 0;
}


/** Header */

#qunit-header {
padding: 0.5em 0 0.5em 1em;

color: #8699a4;
background-color: #0d3349;

font-size: 1.5em;
line-height: 1em;
font-weight: normal;

border-radius: 15px 15px 0 0;
-moz-border-radius: 15px 15px 0 0;
-webkit-border-top-right-radius: 15px;
-webkit-border-top-left-radius: 15px;
}

#qunit-header a {
text-decoration: none;
color: #c2ccd1;
}

#qunit-header a:hover,
#qunit-header a:focus {
color: #fff;
}

#qunit-banner {
height: 5px;
}

#qunit-testrunner-toolbar {
padding: 0.5em 0 0.5em 2em;
color: #5E740B;
background-color: #eee;
}

#qunit-userAgent {
padding: 0.5em 0 0.5em 2.5em;
background-color: #2b81af;
color: #fff;
text-shadow: rgba(0, 0, 0, 0.5) 2px 2px 1px;
}


/** Tests: Pass/Fail */

#qunit-tests {
list-style-position: inside;
}

#qunit-tests li {
padding: 0.4em 0.5em 0.4em 2.5em;
border-bottom: 1px solid #fff;
list-style-position: inside;
}

#qunit-tests.hidepass li.pass, #qunit-tests.hidepass li.running {
display: none;
}

#qunit-tests li strong {
cursor: pointer;
}

#qunit-tests li a {
padding: 0.5em;
color: #c2ccd1;
text-decoration: none;
}
#qunit-tests li a:hover,
#qunit-tests li a:focus {
color: #000;
}

#qunit-tests ol {
margin-top: 0.5em;
padding: 0.5em;

background-color: #fff;

border-radius: 15px;
-moz-border-radius: 15px;
-webkit-border-radius: 15px;

box-shadow: inset 0px 2px 13px #999;
-moz-box-shadow: inset 0px 2px 13px #999;
-webkit-box-shadow: inset 0px 2px 13px #999;
}

#qunit-tests table {
border-collapse: collapse;
margin-top: .2em;
}

#qunit-tests th {
text-align: right;
vertical-align: top;
padding: 0 .5em 0 0;
}

#qunit-tests td {
vertical-align: top;
}

#qunit-tests pre {
margin: 0;
white-space: pre-wrap;
word-wrap: break-word;
}

#qunit-tests del {
background-color: #e0f2be;
color: #374e0c;
text-decoration: none;
}

#qunit-tests ins {
background-color: #ffcaca;
color: #500;
text-decoration: none;
}

/*** Test Counts */

#qunit-tests b.counts { color: black; }
#qunit-tests b.passed { color: #5E740B; }
#qunit-tests b.failed { color: #710909; }

#qunit-tests li li {
margin: 0.5em;
padding: 0.4em 0.5em 0.4em 0.5em;
background-color: #fff;
border-bottom: none;
list-style-position: inside;
}

/*** Passing Styles */

#qunit-tests li li.pass {
color: #5E740B;
background-color: #fff;
border-left: 26px solid #C6E746;
}

#qunit-tests .pass { color: #528CE0; background-color: #D2E0E6; }
#qunit-tests .pass .test-name { color: #366097; }

#qunit-tests .pass .test-actual,
#qunit-tests .pass .test-expected { color: #999999; }

#qunit-banner.qunit-pass { background-color: #C6E746; }

/*** Failing Styles */

#qunit-tests li li.fail {
color: #710909;
background-color: #fff;
border-left: 26px solid #EE5757;
}

#qunit-tests > li:last-child {
border-radius: 0 0 15px 15px;
-moz-border-radius: 0 0 15px 15px;
-webkit-border-bottom-right-radius: 15px;
-webkit-border-bottom-left-radius: 15px;
}

#qunit-tests .fail { color: #000000; background-color: #EE5757; }
#qunit-tests .fail .test-name,
#qunit-tests .fail .module-name { color: #000000; }

#qunit-tests .fail .test-actual { color: #EE5757; }
#qunit-tests .fail .test-expected { color: green; }

#qunit-banner.qunit-fail { background-color: #EE5757; }


/** Result */

#qunit-testresult {
padding: 0.5em 0.5em 0.5em 2.5em;

color: #2b81af;
background-color: #D2E0E6;

border-bottom: 1px solid white;
}

/** Fixture */

#qunit-fixture {
position: absolute;
top: -10000px;
left: -10000px;
}

// ====
// C:\inetpub\wwwroot\WebGL\code\qunit.js
// ----
/**
* QUnit - A JavaScript Unit Testing Framework
*
* http://docs.jquery.com/QUnit
*
* Copyright (c) 2011 John Resig, J�rn Zaefferer
* Dual licensed under the MIT (MIT-LICENSE.txt)
* or GPL (GPL-LICENSE.txt) licenses.
*/

(function (window) {

    var defined = {
        setTimeout: typeof window.setTimeout !== "undefined",
        sessionStorage: (function () {
            try {
                return !!sessionStorage.getItem;
            } catch (e) {
                return false;
            }
        })()
    };

    var testId = 0;

    var Test = function (name, testName, expected, testEnvironmentArg, async, callback) {
        this.name = name;
        this.testName = testName;
        this.expected = expected;
        this.testEnvironmentArg = testEnvironmentArg;
        this.async = async;
        this.callback = callback;
        this.assertions = [];
    };
    Test.prototype = {
        init: function () {
            var tests = id("qunit-tests");
            if (tests) {
                var b = document.createElement("strong");
                b.innerHTML = "Running " + this.name;
                var li = document.createElement("li");
                li.appendChild(b);
                li.className = "running";
                li.id = this.id = "test-output" + testId++;
                tests.appendChild(li);
            }
        },
        setup: function () {
            if (this.module != config.previousModule) {
                if (config.previousModule) {
                    QUnit.moduleDone({
                        name: config.previousModule,
                        failed: config.moduleStats.bad,
                        passed: config.moduleStats.all - config.moduleStats.bad,
                        total: config.moduleStats.all
                    });
                }
                config.previousModule = this.module;
                config.moduleStats = { all: 0, bad: 0 };
                QUnit.moduleStart({
                    name: this.module
                });
            }

            config.current = this;
            this.testEnvironment = extend({
                setup: function () { },
                teardown: function () { }
            }, this.moduleTestEnvironment);
            if (this.testEnvironmentArg) {
                extend(this.testEnvironment, this.testEnvironmentArg);
            }

            QUnit.testStart({
                name: this.testName
            });

            // allow utility functions to access the current test environment
            // TODO why??
            QUnit.current_testEnvironment = this.testEnvironment;

            try {
                if (!config.pollution) {
                    saveGlobal();
                }

                this.testEnvironment.setup.call(this.testEnvironment);
            } catch (e) {
                QUnit.ok(false, "Setup failed on " + this.testName + ": " + e.message);
            }
        },
        run: function () {
            if (this.async) {
                QUnit.stop();
            }

            if (config.notrycatch) {
                this.callback.call(this.testEnvironment);
                return;
            }
            try {
                this.callback.call(this.testEnvironment);
            } catch (e) {
                fail("Test " + this.testName + " died, exception and test follows", e, this.callback);
                QUnit.ok(false, "Died on test #" + (this.assertions.length + 1) + ": " + e.message + " - " + QUnit.jsDump.parse(e));
                // else next test will carry the responsibility
                saveGlobal();

                // Restart the tests if they're blocking
                if (config.blocking) {
                    start();
                }
            }
        },
        teardown: function () {
            try {
                this.testEnvironment.teardown.call(this.testEnvironment);
                checkPollution();
            } catch (e) {
                QUnit.ok(false, "Teardown failed on " + this.testName + ": " + e.message);
            }
        },
        finish: function () {
            if (this.expected && this.expected != this.assertions.length) {
                QUnit.ok(false, "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run");
            }

            var good = 0, bad = 0,
tests = id("qunit-tests");

            config.stats.all += this.assertions.length;
            config.moduleStats.all += this.assertions.length;

            if (tests) {
                var ol = document.createElement("ol");

                for (var i = 0; i < this.assertions.length; i++) {
                    var assertion = this.assertions[i];

                    var li = document.createElement("li");
                    li.className = assertion.result ? "pass" : "fail";
                    li.innerHTML = assertion.message || (assertion.result ? "okay" : "failed");
                    ol.appendChild(li);

                    if (assertion.result) {
                        good++;
                    } else {
                        bad++;
                        config.stats.bad++;
                        config.moduleStats.bad++;
                    }
                }

                // store result when possible
                if (QUnit.config.reorder && defined.sessionStorage) {
                    if (bad) {
                        sessionStorage.setItem("qunit-" + this.module + "-" + this.testName, bad);
                    } else {
                        sessionStorage.removeItem("qunit-" + this.module + "-" + this.testName);
                    }
                }

                if (bad == 0) {
                    ol.style.display = "none";
                }

                var b = document.createElement("strong");
                b.innerHTML = this.name + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";

                var a = document.createElement("a");
                a.innerHTML = "Rerun";
                a.href = QUnit.url({ filter: getText([b]).replace(/\([^)]+\)$/, "").replace(/(^\s*|\s*$)/g, "") });

                addEvent(b, "click", function () {
                    var next = b.nextSibling.nextSibling,
display = next.style.display;
                    next.style.display = display === "none" ? "block" : "none";
                });

                addEvent(b, "dblclick", function (e) {
                    var target = e && e.target ? e.target : window.event.srcElement;
                    if (target.nodeName.toLowerCase() == "span" || target.nodeName.toLowerCase() == "b") {
                        target = target.parentNode;
                    }
                    if (window.location && target.nodeName.toLowerCase() === "strong") {
                        window.location = QUnit.url({ filter: getText([target]).replace(/\([^)]+\)$/, "").replace(/(^\s*|\s*$)/g, "") });
                    }
                });

                var li = id(this.id);
                li.className = bad ? "fail" : "pass";
                li.removeChild(li.firstChild);
                li.appendChild(b);
                li.appendChild(a);
                li.appendChild(ol);

            } else {
                for (var i = 0; i < this.assertions.length; i++) {
                    if (!this.assertions[i].result) {
                        bad++;
                        config.stats.bad++;
                        config.moduleStats.bad++;
                    }
                }
            }

            try {
                QUnit.reset();
            } catch (e) {
                fail("reset() failed, following Test " + this.testName + ", exception and reset fn follows", e, QUnit.reset);
            }

            QUnit.testDone({
                name: this.testName,
                failed: bad,
                passed: this.assertions.length - bad,
                total: this.assertions.length
            });
        },

        queue: function () {
            var test = this;
            synchronize(function () {
                test.init();
            });
            function run() {
                // each of these can by async
                synchronize(function () {
                    test.setup();
                });
                synchronize(function () {
                    test.run();
                });
                synchronize(function () {
                    test.teardown();
                });
                synchronize(function () {
                    test.finish();
                });
            }
            // defer when previous test run passed, if storage is available
            var bad = QUnit.config.reorder && defined.sessionStorage && +sessionStorage.getItem("qunit-" + this.module + "-" + this.testName);
            if (bad) {
                run();
            } else {
                synchronize(run);
            };
        }

    };

    var QUnit = {

        // call on start of module test to prepend name to all tests
        module: function (name, testEnvironment) {
            config.currentModule = name;
            config.currentModuleTestEnviroment = testEnvironment;
        },

        asyncTest: function (testName, expected, callback) {
            if (arguments.length === 2) {
                callback = expected;
                expected = 0;
            }

            QUnit.test(testName, expected, callback, true);
        },

        test: function (testName, expected, callback, async) {
            var name = '<span class="test-name">' + testName + '</span>', testEnvironmentArg;

            if (arguments.length === 2) {
                callback = expected;
                expected = null;
            }
            // is 2nd argument a testEnvironment?
            if (expected && typeof expected === 'object') {
                testEnvironmentArg = expected;
                expected = null;
            }

            if (config.currentModule) {
                name = '<span class="module-name">' + config.currentModule + "</span>: " + name;
            }

            if (!validTest(config.currentModule + ": " + testName)) {
                return;
            }

            var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
            test.module = config.currentModule;
            test.moduleTestEnvironment = config.currentModuleTestEnviroment;
            test.queue();
        },

        /**
        * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
        */
        expect: function (asserts) {
            config.current.expected = asserts;
        },

        /**
        * Asserts true.
        * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
        */
        ok: function (a, msg) {
            a = !!a;
            var details = {
                result: a,
                message: msg
            };
            msg = escapeHtml(msg);
            QUnit.log(details);
            config.current.assertions.push({
                result: a,
                message: msg
            });
        },

        /**
        * Checks that the first two arguments are equal, with an optional message.
        * Prints out both actual and expected values.
        *
        * Prefered to ok( actual == expected, message )
        *
        * @example equal( format("Received {0} bytes.", 2), "Received 2 bytes." );
        *
        * @param Object actual
        * @param Object expected
        * @param String message (optional)
        */
        equal: function (actual, expected, message) {
            QUnit.push(expected == actual, actual, expected, message);
        },

        notEqual: function (actual, expected, message) {
            QUnit.push(expected != actual, actual, expected, message);
        },

        deepEqual: function (actual, expected, message) {
            QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
        },

        notDeepEqual: function (actual, expected, message) {
            QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
        },

        strictEqual: function (actual, expected, message) {
            QUnit.push(expected === actual, actual, expected, message);
        },

        notStrictEqual: function (actual, expected, message) {
            QUnit.push(expected !== actual, actual, expected, message);
        },

        raises: function (block, expected, message) {
            var actual, ok = false;

            if (typeof expected === 'string') {
                message = expected;
                expected = null;
            }

            try {
                block();
            } catch (e) {
                actual = e;
            }

            if (actual) {
                // we don't want to validate thrown error
                if (!expected) {
                    ok = true;
                    // expected is a regexp
                } else if (QUnit.objectType(expected) === "regexp") {
                    ok = expected.test(actual);
                    // expected is a constructor
                } else if (actual instanceof expected) {
                    ok = true;
                    // expected is a validation function which returns true is validation passed
                } else if (expected.call({}, actual) === true) {
                    ok = true;
                }
            }

            QUnit.ok(ok, message);
        },

        start: function () {
            config.semaphore--;
            if (config.semaphore > 0) {
                // don't start until equal number of stop-calls
                return;
            }
            if (config.semaphore < 0) {
                // ignore if start is called more often then stop
                config.semaphore = 0;
            }
            // A slight delay, to avoid any current callbacks
            if (defined.setTimeout) {
                window.setTimeout(function () {
                    if (config.timeout) {
                        clearTimeout(config.timeout);
                    }

                    config.blocking = false;
                    process();
                }, 13);
            } else {
                config.blocking = false;
                process();
            }
        },

        stop: function (timeout) {
            config.semaphore++;
            config.blocking = true;

            if (timeout && defined.setTimeout) {
                clearTimeout(config.timeout);
                config.timeout = window.setTimeout(function () {
                    QUnit.ok(false, "Test timed out");
                    QUnit.start();
                }, timeout);
            }
        }
    };

    // Backwards compatibility, deprecated
    QUnit.equals = QUnit.equal;
    QUnit.same = QUnit.deepEqual;

    // Maintain internal state
    var config = {
        // The queue of tests to run
        queue: [],

        // block until document ready
        blocking: true,

        // by default, run previously failed tests first
        // very useful in combination with "Hide passed tests" checked
        reorder: true,

        noglobals: false,
        notrycatch: false
    };

    // Load paramaters
    (function () {
        var location = window.location || { search: "", protocol: "file:" },
params = location.search.slice(1).split("&"),
length = params.length,
urlParams = {},
current;

        if (params[0]) {
            for (var i = 0; i < length; i++) {
                current = params[i].split("=");
                current[0] = decodeURIComponent(current[0]);
                // allow just a key to turn on a flag, e.g., test.html?noglobals
                current[1] = current[1] ? decodeURIComponent(current[1]) : true;
                urlParams[current[0]] = current[1];
                if (current[0] in config) {
                    config[current[0]] = current[1];
                }
            }
        }

        QUnit.urlParams = urlParams;
        config.filter = urlParams.filter;

        // Figure out if we're running the tests from a server or not
        QUnit.isLocal = !!(location.protocol === 'file:');
    })();

    // Expose the API as global variables, unless an 'exports'
    // object exists, in that case we assume we're in CommonJS
    if (typeof exports === "undefined" || typeof require === "undefined") {
        extend(window, QUnit);
        window.QUnit = QUnit;
    } else {
        extend(exports, QUnit);
        exports.QUnit = QUnit;
    }

    // define these after exposing globals to keep them in these QUnit namespace only
    extend(QUnit, {
        config: config,

        // Initialize the configuration options
        init: function () {
            extend(config, {
                stats: { all: 0, bad: 0 },
                moduleStats: { all: 0, bad: 0 },
                started: +new Date,
                updateRate: 1000,
                blocking: false,
                autostart: true,
                autorun: false,
                filter: "",
                queue: [],
                semaphore: 0
            });

            var tests = id("qunit-tests"),
banner = id("qunit-banner"),
result = id("qunit-testresult");

            if (tests) {
                tests.innerHTML = "";
            }

            if (banner) {
                banner.className = "";
            }

            if (result) {
                result.parentNode.removeChild(result);
            }

            if (tests) {
                result = document.createElement("p");
                result.id = "qunit-testresult";
                result.className = "result";
                tests.parentNode.insertBefore(result, tests);
                result.innerHTML = 'Running...<br/>&nbsp;';
            }
        },

        /**
        * Resets the test setup. Useful for tests that modify the DOM.
        *
        * If jQuery is available, uses jQuery's html(), otherwise just innerHTML.
        */
        reset: function () {
            if (window.jQuery) {
                jQuery("#qunit-fixture").html(config.fixture);
            } else {
                var main = id('qunit-fixture');
                if (main) {
                    main.innerHTML = config.fixture;
                }
            }
        },

        /**
        * Trigger an event on an element.
        *
        * @example triggerEvent( document.body, "click" );
        *
        * @param DOMElement elem
        * @param String type
        */
        triggerEvent: function (elem, type, event) {
            if (document.createEvent) {
                event = document.createEvent("MouseEvents");
                event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
0, 0, 0, 0, 0, false, false, false, false, 0, null);
                elem.dispatchEvent(event);

            } else if (elem.fireEvent) {
                elem.fireEvent("on" + type);
            }
        },

        // Safe object type checking
        is: function (type, obj) {
            return QUnit.objectType(obj) == type;
        },

        objectType: function (obj) {
            if (typeof obj === "undefined") {
                return "undefined";

                // consider: typeof null === object
            }
            if (obj === null) {
                return "null";
            }

            var type = Object.prototype.toString.call(obj)
.match(/^\[object\s(.*)\]$/)[1] || '';

            switch (type) {
                case 'Number':
                    if (isNaN(obj)) {
                        return "nan";
                    } else {
                        return "number";
                    }
                case 'String':
                case 'Boolean':
                case 'Array':
                case 'Date':
                case 'RegExp':
                case 'Function':
                    return type.toLowerCase();
            }
            if (typeof obj === "object") {
                return "object";
            }
            return undefined;
        },

        push: function (result, actual, expected, message) {
            var details = {
                result: result,
                message: message,
                actual: actual,
                expected: expected
            };

            message = escapeHtml(message) || (result ? "okay" : "failed");
            message = '<span class="test-message">' + message + "</span>";
            expected = escapeHtml(QUnit.jsDump.parse(expected));
            actual = escapeHtml(QUnit.jsDump.parse(actual));
            var output = message + '<table><tr class="test-expected"><th>Expected: </th><td><pre>' + expected + '</pre></td></tr>';
            if (actual != expected) {
                output += '<tr class="test-actual"><th>Result: </th><td><pre>' + actual + '</pre></td></tr>';
                output += '<tr class="test-diff"><th>Diff: </th><td><pre>' + QUnit.diff(expected, actual) + '</pre></td></tr>';
            }
            if (!result) {
                var source = sourceFromStacktrace();
                if (source) {
                    details.source = source;
                    output += '<tr class="test-source"><th>Source: </th><td><pre>' + escapeHtml(source) + '</pre></td></tr>';
                }
            }
            output += "</table>";

            QUnit.log(details);

            config.current.assertions.push({
                result: !!result,
                message: output
            });
        },

        url: function (params) {
            params = extend(extend({}, QUnit.urlParams), params);
            var querystring = "?",
key;
            for (key in params) {
                querystring += encodeURIComponent(key) + "=" +
encodeURIComponent(params[key]) + "&";
            }
            return window.location.pathname + querystring.slice(0, -1);
        },

        extend: extend,
        id: id,
        addEvent: addEvent,

        // Logging callbacks; all receive a single argument with the listed properties
        // run test/logs.html for any related changes
        begin: function () { },
        // done: { failed, passed, total, runtime }
        done: function () { },
        // log: { result, actual, expected, message }
        log: function () { },
        // testStart: { name }
        testStart: function () { },
        // testDone: { name, failed, passed, total }
        testDone: function () { },
        // moduleStart: { name }
        moduleStart: function () { },
        // moduleDone: { name, failed, passed, total }
        moduleDone: function () { }
    });

    if (typeof document === "undefined" || document.readyState === "complete") {
        config.autorun = true;
    }

    addEvent(window, "load", function () {
        QUnit.begin({});

        // Initialize the config, saving the execution queue
        var oldconfig = extend({}, config);
        QUnit.init();
        extend(config, oldconfig);

        config.blocking = false;

        var userAgent = id("qunit-userAgent");
        if (userAgent) {
            userAgent.innerHTML = navigator.userAgent;
        }
        var banner = id("qunit-header");
        if (banner) {
            banner.innerHTML = '<a href="' + QUnit.url({ filter: undefined }) + '"> ' + banner.innerHTML + '</a> ' +
'<label><input name="noglobals" type="checkbox"' + (config.noglobals ? ' checked="checked"' : '') + '>noglobals</label>' +
'<label><input name="notrycatch" type="checkbox"' + (config.notrycatch ? ' checked="checked"' : '') + '>notrycatch</label>';
            addEvent(banner, "change", function (event) {
                var params = {};
                params[event.target.name] = event.target.checked ? true : undefined;
                window.location = QUnit.url(params);
            });
        }

        var toolbar = id("qunit-testrunner-toolbar");
        if (toolbar) {
            var filter = document.createElement("input");
            filter.type = "checkbox";
            filter.id = "qunit-filter-pass";
            addEvent(filter, "click", function () {
                var ol = document.getElementById("qunit-tests");
                if (filter.checked) {
                    ol.className = ol.className + " hidepass";
                } else {
                    var tmp = " " + ol.className.replace(/[\n\t\r]/g, " ") + " ";
                    ol.className = tmp.replace(/ hidepass /, " ");
                }
                if (defined.sessionStorage) {
                    if (filter.checked) {
                        sessionStorage.setItem("qunit-filter-passed-tests", "true");
                    } else {
                        sessionStorage.removeItem("qunit-filter-passed-tests");
                    }
                }
            });
            if (defined.sessionStorage && sessionStorage.getItem("qunit-filter-passed-tests")) {
                filter.checked = true;
                var ol = document.getElementById("qunit-tests");
                ol.className = ol.className + " hidepass";
            }
            toolbar.appendChild(filter);

            var label = document.createElement("label");
            label.setAttribute("for", "qunit-filter-pass");
            label.innerHTML = "Hide passed tests";
            toolbar.appendChild(label);
        }

        var main = id('qunit-fixture');
        if (main) {
            config.fixture = main.innerHTML;
        }

        if (config.autostart) {
            QUnit.start();
        }
    });

    function done() {
        config.autorun = true;

        // Log the last module results
        if (config.currentModule) {
            QUnit.moduleDone({
                name: config.currentModule,
                failed: config.moduleStats.bad,
                passed: config.moduleStats.all - config.moduleStats.bad,
                total: config.moduleStats.all
            });
        }

        var banner = id("qunit-banner"),
tests = id("qunit-tests"),
runtime = +new Date - config.started,
passed = config.stats.all - config.stats.bad,
html = [
'Tests completed in ',
runtime,
' milliseconds.<br/>',
'<span class="passed">',
passed,
'</span> tests of <span class="total">',
config.stats.all,
'</span> passed, <span class="failed">',
config.stats.bad,
'</span> failed.'
].join('');

        if (banner) {
            banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
        }

        if (tests) {
            id("qunit-testresult").innerHTML = html;
        }

        if (typeof document !== "undefined" && document.title) {
            // show ? for bad, ? for good suite result in title
            // use escape sequences in case file gets loaded with non-utf-8-charset
            document.title = (config.stats.bad ? "\u2716" : "\u2714") + " " + document.title;
        }

        QUnit.done({
            failed: config.stats.bad,
            passed: passed,
            total: config.stats.all,
            runtime: runtime
        });
    }

    function validTest(name) {
        var filter = config.filter,
run = false;

        if (!filter) {
            return true;
        }

        var not = filter.charAt(0) === "!";
        if (not) {
            filter = filter.slice(1);
        }

        if (name.indexOf(filter) !== -1) {
            return !not;
        }

        if (not) {
            run = true;
        }

        return run;
    }

    // so far supports only Firefox, Chrome and Opera (buggy)
    // could be extended in the future to use something like https://github.com/csnover/TraceKit
    function sourceFromStacktrace() {
        try {
            throw new Error();
        } catch (e) {
            if (e.stacktrace) {
                // Opera
                return e.stacktrace.split("\n")[6];
            } else if (e.stack) {
                // Firefox, Chrome
                return e.stack.split("\n")[4];
            }
        }
    }

    function escapeHtml(s) {
        if (!s) {
            return "";
        }
        s = s + "";
        return s.replace(/[\&"<>\\]/g, function (s) {
            switch (s) {
                case "&": return "&amp;";
                case "\\": return "\\\\";
                case '"': return '\"';
                case "<": return "&lt;";
                case ">": return "&gt;";
                default: return s;
            }
        });
    }

    function synchronize(callback) {
        config.queue.push(callback);

        if (config.autorun && !config.blocking) {
            process();
        }
    }

    function process() {
        var start = (new Date()).getTime();

        while (config.queue.length && !config.blocking) {
            if (config.updateRate <= 0 || (((new Date()).getTime() - start) < config.updateRate)) {
                config.queue.shift()();
            } else {
                window.setTimeout(process, 13);
                break;
            }
        }
        if (!config.blocking && !config.queue.length) {
            done();
        }
    }

    function saveGlobal() {
        config.pollution = [];

        if (config.noglobals) {
            for (var key in window) {
                config.pollution.push(key);
            }
        }
    }

    function checkPollution(name) {
        var old = config.pollution;
        saveGlobal();

        var newGlobals = diff(config.pollution, old);
        if (newGlobals.length > 0) {
            ok(false, "Introduced global variable(s): " + newGlobals.join(", "));
        }

        var deletedGlobals = diff(old, config.pollution);
        if (deletedGlobals.length > 0) {
            ok(false, "Deleted global variable(s): " + deletedGlobals.join(", "));
        }
    }

    // returns a new Array with the elements that are in a but not in b
    function diff(a, b) {
        var result = a.slice();
        for (var i = 0; i < result.length; i++) {
            for (var j = 0; j < b.length; j++) {
                if (result[i] === b[j]) {
                    result.splice(i, 1);
                    i--;
                    break;
                }
            }
        }
        return result;
    }

    function fail(message, exception, callback) {
        if (typeof console !== "undefined" && console.error && console.warn) {
            console.error(message);
            console.error(exception);
            console.warn(callback.toString());

        } else if (window.opera && opera.postError) {
            opera.postError(message, exception, callback.toString);
        }
    }

    function extend(a, b) {
        for (var prop in b) {
            if (b[prop] === undefined) {
                delete a[prop];
            } else {
                a[prop] = b[prop];
            }
        }

        return a;
    }

    function addEvent(elem, type, fn) {
        if (elem.addEventListener) {
            elem.addEventListener(type, fn, false);
        } else if (elem.attachEvent) {
            elem.attachEvent("on" + type, fn);
        } else {
            fn();
        }
    }

    function id(name) {
        return !!(typeof document !== "undefined" && document && document.getElementById) &&
document.getElementById(name);
    }

    // Test for equality any JavaScript type.
    // Discussions and reference: http://philrathe.com/articles/equiv
    // Test suites: http://philrathe.com/tests/equiv
    // Author: Philippe Rath� <prathe@gmail.com>
    QUnit.equiv = function () {

        var innerEquiv; // the real equiv function
        var callers = []; // stack to decide between skip/abort functions
        var parents = []; // stack to avoiding loops from circular referencing

        // Call the o related callback with the given arguments.
        function bindCallbacks(o, callbacks, args) {
            var prop = QUnit.objectType(o);
            if (prop) {
                if (QUnit.objectType(callbacks[prop]) === "function") {
                    return callbacks[prop].apply(callbacks, args);
                } else {
                    return callbacks[prop]; // or undefined
                }
            }
        }

        var callbacks = function () {

            // for string, boolean, number and null
            function useStrictEquality(b, a) {
                if (b instanceof a.constructor || a instanceof b.constructor) {
                    // to catch short annotaion VS 'new' annotation of a declaration
                    // e.g. var i = 1;
                    // var j = new Number(1);
                    return a == b;
                } else {
                    return a === b;
                }
            }

            return {
                "string": useStrictEquality,
                "boolean": useStrictEquality,
                "number": useStrictEquality,
                "null": useStrictEquality,
                "undefined": useStrictEquality,

                "nan": function (b) {
                    return isNaN(b);
                },

                "date": function (b, a) {
                    return QUnit.objectType(b) === "date" && a.valueOf() === b.valueOf();
                },

                "regexp": function (b, a) {
                    return QUnit.objectType(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
                },

                // - skip when the property is a method of an instance (OOP)
                // - abort otherwise,
                // initial === would have catch identical references anyway
                "function": function () {
                    var caller = callers[callers.length - 1];
                    return caller !== Object &&
                        typeof caller !== "undefined";
                },

                "array": function (b, a) {
                    var i, j, loop;
                    var len;

                    // b could be an object literal here
                    if (!(QUnit.objectType(b) === "array")) {
                        return false;
                    }

                    len = a.length;
                    if (len !== b.length) { // safe and faster
                        return false;
                    }

                    //track reference to avoid circular references
                    parents.push(a);
                    for (i = 0; i < len; i++) {
                        loop = false;
                        for (j = 0; j < parents.length; j++) {
                            if (parents[j] === a[i]) {
                                loop = true; //dont rewalk array
                            }
                        }
                        if (!loop && !innerEquiv(a[i], b[i])) {
                            parents.pop();
                            return false;
                        }
                    }
                    parents.pop();
                    return true;
                },

                "object": function (b, a) {
                    var i, j, loop;
                    var eq = true; // unless we can proove it
                    var aProperties = [], bProperties = []; // collection of strings

                    // comparing constructors is more strict than using instanceof
                    if (a.constructor !== b.constructor) {
                        return false;
                    }

                    // stack constructor before traversing properties
                    callers.push(a.constructor);
                    //track reference to avoid circular references
                    parents.push(a);

                    for (i in a) { // be strict: don't ensures hasOwnProperty and go deep
                        loop = false;
                        for (j = 0; j < parents.length; j++) {
                            if (parents[j] === a[i])
                                loop = true; //don't go down the same path twice
                        }
                        aProperties.push(i); // collect a's properties

                        if (!loop && !innerEquiv(a[i], b[i])) {
                            eq = false;
                            break;
                        }
                    }

                    callers.pop(); // unstack, we are done
                    parents.pop();

                    for (i in b) {
                        bProperties.push(i); // collect b's properties
                    }

                    // Ensures identical properties name
                    return eq && innerEquiv(aProperties.sort(), bProperties.sort());
                }
            };
        } ();

        innerEquiv = function () { // can take multiple arguments
            var args = Array.prototype.slice.apply(arguments);
            if (args.length < 2) {
                return true; // end transition
            }

            return (function (a, b) {
                if (a === b) {
                    return true; // catch the most you can
                } else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || QUnit.objectType(a) !== QUnit.objectType(b)) {
                    return false; // don't lose time with error prone cases
                } else {
                    return bindCallbacks(a, callbacks, [b, a]);
                }

                // apply transition with (1..n) arguments
            })(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length - 1));
        };

        return innerEquiv;

    } ();

    /**
    * jsDump
    * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
    * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
    * Date: 5/15/2008
    * @projectDescription Advanced and extensible data dumping for Javascript.
    * @version 1.0.0
    * @author Ariel Flesler
    * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
    */
    QUnit.jsDump = (function () {
        function quote(str) {
            return '"' + str.toString().replace(/"/g, '\\"') + '"';
        };
        function literal(o) {
            return o + '';
        };
        function join(pre, arr, post) {
            var s = jsDump.separator(),
base = jsDump.indent(),
inner = jsDump.indent(1);
            if (arr.join)
                arr = arr.join(',' + s + inner);
            if (!arr)
                return pre + post;
            return [pre, inner + arr, base + post].join(s);
        };
        function array(arr) {
            var i = arr.length, ret = Array(i);
            this.up();
            while (i--)
                ret[i] = this.parse(arr[i]);
            this.down();
            return join('[', ret, ']');
        };

        var reName = /^function (\w+)/;

        var jsDump = {
            parse: function (obj, type) { //type is used mostly internally, you can fix a (custom)type in advance
                var parser = this.parsers[type || this.typeOf(obj)];
                type = typeof parser;

                return type == 'function' ? parser.call(this, obj) :
type == 'string' ? parser :
this.parsers.error;
            },
            typeOf: function (obj) {
                var type;
                if (obj === null) {
                    type = "null";
                } else if (typeof obj === "undefined") {
                    type = "undefined";
                } else if (QUnit.is("RegExp", obj)) {
                    type = "regexp";
                } else if (QUnit.is("Date", obj)) {
                    type = "date";
                } else if (QUnit.is("Function", obj)) {
                    type = "function";
                } else if (typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined") {
                    type = "window";
                } else if (obj.nodeType === 9) {
                    type = "document";
                } else if (obj.nodeType) {
                    type = "node";
                } else if (typeof obj === "object" && typeof obj.length === "number" && obj.length >= 0) {
                    type = "array";
                } else {
                    type = typeof obj;
                }
                return type;
            },
            separator: function () {
                return this.multiline ? this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
            },
            indent: function (extra) {// extra can be a number, shortcut for increasing-calling-decreasing
                if (!this.multiline)
                    return '';
                var chr = this.indentChar;
                if (this.HTML)
                    chr = chr.replace(/\t/g, ' ').replace(/ /g, '&nbsp;');
                return Array(this._depth_ + (extra || 0)).join(chr);
            },
            up: function (a) {
                this._depth_ += a || 1;
            },
            down: function (a) {
                this._depth_ -= a || 1;
            },
            setParser: function (name, parser) {
                this.parsers[name] = parser;
            },
            // The next 3 are exposed so you can use them
            quote: quote,
            literal: literal,
            join: join,
            //
            _depth_: 1,
            // This is the list of parsers, to modify them, use jsDump.setParser
            parsers: {
                window: '[Window]',
                document: '[Document]',
                error: '[ERROR]', //when no parser is found, shouldn't happen
                unknown: '[Unknown]',
                'null': 'null',
                'undefined': 'undefined',
                'function': function (fn) {
                    var ret = 'function',
name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1]; //functions never have name in IE
                    if (name)
                        ret += ' ' + name;
                    ret += '(';

                    ret = [ret, QUnit.jsDump.parse(fn, 'functionArgs'), '){'].join('');
                    return join(ret, QUnit.jsDump.parse(fn, 'functionCode'), '}');
                },
                array: array,
                nodelist: array,
                arguments: array,
                object: function (map) {
                    var ret = [];
                    QUnit.jsDump.up();
                    for (var key in map)
                        ret.push(QUnit.jsDump.parse(key, 'key') + ': ' + QUnit.jsDump.parse(map[key]));
                    QUnit.jsDump.down();
                    return join('{', ret, '}');
                },
                node: function (node) {
                    var open = QUnit.jsDump.HTML ? '&lt;' : '<',
close = QUnit.jsDump.HTML ? '&gt;' : '>';

                    var tag = node.nodeName.toLowerCase(),
ret = open + tag;

                    for (var a in QUnit.jsDump.DOMAttrs) {
                        var val = node[QUnit.jsDump.DOMAttrs[a]];
                        if (val)
                            ret += ' ' + a + '=' + QUnit.jsDump.parse(val, 'attribute');
                    }
                    return ret + close + open + '/' + tag + close;
                },
                functionArgs: function (fn) {//function calls it internally, it's the arguments part of the function
                    var l = fn.length;
                    if (!l) return '';

                    var args = Array(l);
                    while (l--)
                        args[l] = String.fromCharCode(97 + l); //97 is 'a'
                    return ' ' + args.join(', ') + ' ';
                },
                key: quote, //object calls it internally, the key part of an item in a map
                functionCode: '[code]', //function calls it internally, it's the content of the function
                attribute: quote, //node calls it internally, it's an html attribute value
                string: quote,
                date: quote,
                regexp: literal, //regex
                number: literal,
                'boolean': literal
            },
            DOMAttrs: {//attributes to dump from nodes, name=>realName
                id: 'id',
                name: 'name',
                'class': 'className'
            },
            HTML: false, //if true, entities are escaped ( <, >, \t, space and \n )
            indentChar: ' ', //indentation unit
            multiline: true //if true, items in a collection, are separated by a \n, else just a space.
        };

        return jsDump;
    })();

    // from Sizzle.js
    function getText(elems) {
        var ret = "", elem;

        for (var i = 0; elems[i]; i++) {
            elem = elems[i];

            // Get the text from text nodes and CDATA nodes
            if (elem.nodeType === 3 || elem.nodeType === 4) {
                ret += elem.nodeValue;

                // Traverse everything else, except comment nodes
            } else if (elem.nodeType !== 8) {
                ret += getText(elem.childNodes);
            }
        }

        return ret;
    };

    /*
    * Javascript Diff Algorithm
    * By John Resig (http://ejohn.org/)
    * Modified by Chu Alan "sprite"
    *
    * Released under the MIT license.
    *
    * More Info:
    * http://ejohn.org/projects/javascript-diff-algorithm/
    *
    * Usage: QUnit.diff(expected, actual)
    *
    * QUnit.diff("the quick brown fox jumped over", "the quick fox jumps over") == "the quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
    */
    QUnit.diff = (function () {
        function diff(o, n) {
            var ns = new Object();
            var os = new Object();

            for (var i = 0; i < n.length; i++) {
                if (ns[n[i]] == null)
                    ns[n[i]] = {
                        rows: new Array(),
                        o: null
                    };
                ns[n[i]].rows.push(i);
            }

            for (var i = 0; i < o.length; i++) {
                if (os[o[i]] == null)
                    os[o[i]] = {
                        rows: new Array(),
                        n: null
                    };
                os[o[i]].rows.push(i);
            }

            for (var i in ns) {
                if (ns[i].rows.length == 1 && typeof (os[i]) != "undefined" && os[i].rows.length == 1) {
                    n[ns[i].rows[0]] = {
                        text: n[ns[i].rows[0]],
                        row: os[i].rows[0]
                    };
                    o[os[i].rows[0]] = {
                        text: o[os[i].rows[0]],
                        row: ns[i].rows[0]
                    };
                }
            }

            for (var i = 0; i < n.length - 1; i++) {
                if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
n[i + 1] == o[n[i].row + 1]) {
                    n[i + 1] = {
                        text: n[i + 1],
                        row: n[i].row + 1
                    };
                    o[n[i].row + 1] = {
                        text: o[n[i].row + 1],
                        row: i + 1
                    };
                }
            }

            for (var i = n.length - 1; i > 0; i--) {
                if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
n[i - 1] == o[n[i].row - 1]) {
                    n[i - 1] = {
                        text: n[i - 1],
                        row: n[i].row - 1
                    };
                    o[n[i].row - 1] = {
                        text: o[n[i].row - 1],
                        row: i - 1
                    };
                }
            }

            return {
                o: o,
                n: n
            };
        }

        return function (o, n) {
            o = o.replace(/\s+$/, '');
            n = n.replace(/\s+$/, '');
            var out = diff(o == "" ? [] : o.split(/\s+/), n == "" ? [] : n.split(/\s+/));

            var str = "";

            var oSpace = o.match(/\s+/g);
            if (oSpace == null) {
                oSpace = [" "];
            }
            else {
                oSpace.push(" ");
            }
            var nSpace = n.match(/\s+/g);
            if (nSpace == null) {
                nSpace = [" "];
            }
            else {
                nSpace.push(" ");
            }

            if (out.n.length == 0) {
                for (var i = 0; i < out.o.length; i++) {
                    str += '<del>' + out.o[i] + oSpace[i] + "</del>";
                }
            }
            else {
                if (out.n[0].text == null) {
                    for (n = 0; n < out.o.length && out.o[n].text == null; n++) {
                        str += '<del>' + out.o[n] + oSpace[n] + "</del>";
                    }
                }

                for (var i = 0; i < out.n.length; i++) {
                    if (out.n[i].text == null) {
                        str += '<ins>' + out.n[i] + nSpace[i] + "</ins>";
                    }
                    else {
                        var pre = "";

                        for (n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++) {
                            pre += '<del>' + out.o[n] + oSpace[n] + "</del>";
                        }
                        str += " " + out.n[i].text + nSpace[i] + pre;
                    }
                }
            }

            return str;
        };
    })();

})(this);

// ====
// C:\inetpub\wwwroot\WebGL\code\shaderProgram.js
// ----
function ShaderProgram(gl, vShaderPath, fShaderPath) {

    var vShaderScript = getSourceSync(vShaderPath);
    var fShaderScript = getSourceSync(fShaderPath);

    var program = initShaders(getVShader(vShaderScript), getFShader(fShaderScript));

    program.setAttribLocation = function(name) {
        this[name] = gl.getAttribLocation(this, name);
    };

    program.setUniformLocation = function(name) {
        this[name] = gl.getUniformLocation(this, name);
    };

    return program;

    // helper functions
    // ----------------

    function getSourceSync(url) {
        var req = new window.XMLHttpRequest();
        req.open('GET', url + '?t=' + new Date(), false); // prevent caching
        req.send(null);
        return (req.status == 200 || req.status == 304) ? req.responseText : null;
    }

    function getVShader(shaderScript) {
        if (!shaderScript) return null;
        var shader = gl.createShader(gl.VERTEX_SHADER);
        return getShader(shader, shaderScript);
    }

    function getFShader(shaderScript) {
        if (!shaderScript) return null;
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        return getShader(shader, shaderScript);
    }

    function getShader(shader, shaderScript) {
        if (!shader || !shaderScript) return null;
        gl.shaderSource(shader, shaderScript);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw gl.getShaderInfoLog(shader);
        }

        return shader;
    }

    function initShaders(vShader, fShader) {
        if (!vShader || !fShader)
            throw 'vShader and fShader must not be null';

        var shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, vShader);
        gl.attachShader(shaderProgram, fShader);

        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
            throw 'Could not initialise shaders';

        return shaderProgram;
    }
}


// ====
// C:\inetpub\wwwroot\WebGL\code\simplex.js
// ----
// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
* You can pass in a random number generator object if you like.
* It is assumed to have a random() method.
*/

function Prng() {
	var m_w = 123456789;
	var m_z = 987654321;
	var mask = 0xffffffff;

// Takes any integer
    this.seed = function(i) {
        m_w = i;
    };

// Returns number between 0 (inclusive) and 1.0 (exclusive), just like Math.random().
    this.random = function() {
        m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
        m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
        var result = ((m_z << 16) + m_w) & mask;
        result /= 4294967296;
        return result + 0.5;
    };
}


var SimplexNoise = function(r) {
    if (r == undefined) r = new Prng();
    this.grad3 = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];
    this.p = [];
    for (var i = 0; i < 256; i++) {
        this.p[i] = Math.floor(r.random() * 256);
    }
    // To remove the need for index wrapping, double the permutation table length
    this.perm = [];
    for (var i = 0; i < 512; i++) {
        this.perm[i] = this.p[i & 255];
    }
};

SimplexNoise.prototype.dot = function(g, x, y) {
    return g[0] * x + g[1] * y;
};

SimplexNoise.prototype.noise = function(xin, yin) {
  var n0, n1, n2; // Noise contributions from the three corners
  // Skew the input space to determine which simplex cell we're in
  var F2 = 0.5*(Math.sqrt(3.0)-1.0);
  var s = (xin+yin)*F2; // Hairy factor for 2D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var G2 = (3.0-Math.sqrt(3.0))/6.0;
  var t = (i+j)*G2;
  var X0 = i-t; // Unskew the cell origin back to (x,y) space
  var Y0 = j-t;
  var x0 = xin-X0; // The x,y distances from the cell origin
  var y0 = yin-Y0;
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  var y1 = y0 - j1 + G2;
  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  var y2 = y0 - 1.0 + 2.0 * G2;
  // Work out the hashed gradient indices of the three simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var gi0 = this.perm[ii+this.perm[jj]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12;
  var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12;
  // Calculate the contribution from the three corners
  var t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }
  var t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
  }
  var t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
};

// 3D simplex noise
SimplexNoise.prototype.noise3d = function(xin, yin, zin) {
  var n0, n1, n2, n3; // Noise contributions from the four corners
  // Skew the input space to determine which simplex cell we're in
  var F3 = 1.0/3.0;
  var s = (xin+yin+zin)*F3; // Very nice and simple skew factor for 3D
  var i = Math.floor(xin+s);
  var j = Math.floor(yin+s);
  var k = Math.floor(zin+s);
  var G3 = 1.0/6.0; // Very nice and simple unskew factor, too
  var t = (i+j+k)*G3;
  var X0 = i-t; // Unskew the cell origin back to (x,y,z) space
  var Y0 = j-t;
  var Z0 = k-t;
  var x0 = xin-X0; // The x,y,z distances from the cell origin
  var y0 = yin-Y0;
  var z0 = zin-Z0;
  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
  // Determine which simplex we are in.
  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
  if(x0>=y0) {
    if(y0>=z0)
      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
      else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
      else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
    }
  else { // x0<y0
    if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
    else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
  }
  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
  // c = 1/6.
  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
  var y1 = y0 - j1 + G3;
  var z1 = z0 - k1 + G3;
  var x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
  var y2 = y0 - j2 + 2.0*G3;
  var z2 = z0 - k2 + 2.0*G3;
  var x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
  var y3 = y0 - 1.0 + 3.0*G3;
  var z3 = z0 - 1.0 + 3.0*G3;
  // Work out the hashed gradient indices of the four simplex corners
  var ii = i & 255;
  var jj = j & 255;
  var kk = k & 255;
  var gi0 = this.perm[ii+this.perm[jj+this.perm[kk]]] % 12;
  var gi1 = this.perm[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]] % 12;
  var gi2 = this.perm[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]] % 12;
  var gi3 = this.perm[ii+1+this.perm[jj+1+this.perm[kk+1]]] % 12;
  
  // Calculate the contribution from the four corners
  var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
  if(t0<0) n0 = 0.0;
  else {
    t0 *= t0;
    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
  }
  var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
  if(t1<0) n1 = 0.0;
  else {
    t1 *= t1;
    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
  }
  var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
  if(t2<0) n2 = 0.0;
  else {
    t2 *= t2;
    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
  }
  var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
  if(t3<0) n3 = 0.0;
  else {
    t3 *= t3;
    n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
  }
  // Add contributions from each corner to get the final noise value.
  // The result is scaled to stay just inside [-1,1]
  
  return 32.0*(n0 + n1 + n2 + n3);
};

SimplexNoise.prototype.noises3d = function(xin, yin, zin, nOctaves, persistence) {
    var total = 0;
    for (var i = 0; i < nOctaves; i++) {
        var frequency = Math.pow(2.0, i);
        var amplitude = Math.pow(persistence, i);
        total += this.noise3d(xin * frequency, yin * frequency, zin * frequency) * amplitude;
    }
    return total;
};


// ====
// C:\inetpub\wwwroot\WebGL\code\sphere.js
// ----
function Sphere(gl, sp, p, radius, subDivisionDepth, adjust) {
    //subDivisionDepth: 0 => 36, 1=> 129, 2 => 486, 3 => 1890, 4 => 7443, 5 => 29529, 6 => 117528

    var x = radius * 0.525731112119133606;
    var z = radius * 0.850650808352039932;
    var vtxPosStore = {};
    vtxPosStore[[-x, 0, z]] = 0;
    vtxPosStore[[x, 0, z]] = 1;
    vtxPosStore[[-x, 0, -z]] = 2;
    vtxPosStore[[x, 0, -z]] = 3;
    vtxPosStore[[0, z, x]] = 4;
    vtxPosStore[[0, z, -x]] = 5;
    vtxPosStore[[0, -z, x]] = 6;
    vtxPosStore[[0, -z, -x]] = 7;
    vtxPosStore[[z, x, 0]] = 8;
    vtxPosStore[[-z, x, 0]] = 9;
    vtxPosStore[[z, -x, 0]] = 10;
    vtxPosStore[[-z, -x, 0]] = 11;
    var vtxPosStoreSize = 12;

    var vtxIndStore = [
        [0, 4, 1], [0, 9, 4], [9, 5, 4], [4, 5, 8], [4, 8, 1],
        [8, 10, 1], [8, 3, 10], [5, 3, 8], [5, 2, 3], [2, 7, 3],
        [7, 10, 3], [7, 6, 10], [7, 11, 6], [11, 0, 6], [0, 1, 6],
        [6, 1, 10], [9, 0, 11], [9, 11, 2], [9, 2, 5], [7, 2, 11]
    ];

    var _subDivide = function(depth) {
        vtxIndStore = [];
        _doSubDivide([-x, 0, z], [0, z, x], [x, 0, z], depth);
        _doSubDivide([-x, 0, z], [-z, x, 0], [0, z, x], depth);
        _doSubDivide([-z, x, 0], [0, z, -x], [0, z, x], depth);
        _doSubDivide([0, z, x], [0, z, -x], [z, x, 0], depth);
        _doSubDivide([0, z, x], [z, x, 0], [x, 0, z], depth);

        _doSubDivide([z, x, 0], [z, -x, 0], [x, 0, z], depth);
        _doSubDivide([z, x, 0], [x, 0, -z], [z, -x, 0], depth);
        _doSubDivide([0, z, -x], [x, 0, -z], [z, x, 0], depth);
        _doSubDivide([0, z, -x], [-x, 0, -z], [x, 0, -z], depth);
        _doSubDivide([-x, 0, -z], [0, -z, -x], [x, 0, -z], depth);

        _doSubDivide([0, -z, -x], [z, -x, 0], [x, 0, -z], depth);
        _doSubDivide([0, -z, -x], [0, -z, x], [z, -x, 0], depth);
        _doSubDivide([0, -z, -x], [-z, -x, 0], [0, -z, x], depth);
        _doSubDivide([-z, -x, 0], [-x, 0, z], [0, -z, x], depth);
        _doSubDivide([-x, 0, z], [x, 0, z], [0, -z, x], depth);

        _doSubDivide([0, -z, x], [x, 0, z], [z, -x, 0], depth);
        _doSubDivide([-z, x, 0], [-x, 0, z], [-z, -x, 0], depth);
        _doSubDivide([-z, x, 0], [-z, -x, 0], [-x, 0, -z], depth);
        _doSubDivide([-z, x, 0], [-x, 0, -z], [0, z, -x], depth);
        _doSubDivide([0, -z, -x], [-x, 0, -z], [-z, -x, 0], depth);

        //		console.log(vtxIndStore);
    };

    var _doSubDivide = function(v0, v1, v2, depth) {
        if (depth < 0)
            return;

        if (depth == 0) {
            vtxIndStore.push([vtxPosStore[v0], vtxPosStore[v1], vtxPosStore[v2]]);
            return;
        }

        var v12 = vec3.scale(vec3.add(v1, v2, []), 0.5, []);
        var v20 = vec3.scale(vec3.add(v2, v0, []), 0.5, []);
        var v01 = vec3.scale(vec3.add(v0, v1, []), 0.5, []);

        v12 = vec3.scale(v12, radius / Math.sqrt(vec3.dot(v12, v12)), []);
        v20 = vec3.scale(v20, radius / Math.sqrt(vec3.dot(v20, v20)), []);
        v01 = vec3.scale(v01, radius / Math.sqrt(vec3.dot(v01, v01)), []);

        var vi12 = vtxPosStore[v12];
        if (!vi12) {
            vi12 = vtxPosStore[v12] = vtxPosStoreSize;
            vtxPosStoreSize++;
        }
        var vi20 = vtxPosStore[v20];
        if (!vi20) {
            vi20 = vtxPosStore[v20] = vtxPosStoreSize;
            vtxPosStoreSize++;
        }
        var vi01 = vtxPosStore[v01];
        if (!vi01) {
            vi01 = vtxPosStore[v01] = vtxPosStoreSize;
            vtxPosStoreSize++;
        }
        _doSubDivide(v0, v01, v20, depth - 1);
        _doSubDivide(v01, v1, v12, depth - 1);
        _doSubDivide(v20, v12, v2, depth - 1);
        _doSubDivide(v12, v20, v01, depth - 1);
    };

    this.getVtxPos = function() {
        var flatArray = [];
        for (var prop in vtxPosStore) {
            var xy = prop.indexOf(',');
            var yz = prop.indexOf(',', xy + 1);
            var _x = prop.substring(0, xy);
            var _y = prop.substring(xy + 1, yz);
            var _z = prop.substring(yz + 1);

            var parsedX = parseFloat(_x);
            var parsedY = parseFloat(_y);
            var parsedZ = parseFloat(_z);

            if (adjust) {
                var adjusted = adjust([parsedX, parsedY, parsedZ]);
                parsedX = adjusted[0];
                parsedY = adjusted[1];
                parsedZ = adjusted[2];
            }

            flatArray.push(parsedX);
            flatArray.push(parsedY);
            flatArray.push(parsedZ);
        }

        //console.log(flatArray);
        return flatArray;
    };

    this.getVtxNor = function() {
        // normal at 0th vertex will come from the average of all triangles including the 0th vertex
        var vtxNorStore = [];
        for (var i = 0; i < vtxPos.length / 3; i++) { // note: divide by three because the given array is flattened
            vtxNorStore.push([0, 0, 0]);
        }
        for (var i = 0; i < vtxIndStore.length; i++) {
            // for each element, get the three vertices corresponding to the 0th, 1st and 2nd indices of the current triangle
            var v0 = [vtxPos[3 * vtxIndStore[i][0]], vtxPos[1 + 3 * vtxIndStore[i][0]], vtxPos[2 + 3 * vtxIndStore[i][0]]];
            var v1 = [vtxPos[3 * vtxIndStore[i][1]], vtxPos[1 + 3 * vtxIndStore[i][1]], vtxPos[2 + 3 * vtxIndStore[i][1]]];
            var v2 = [vtxPos[3 * vtxIndStore[i][2]], vtxPos[1 + 3 * vtxIndStore[i][2]], vtxPos[2 + 3 * vtxIndStore[i][2]]];
            // calculate 1-0 and 2-0 vectors, then cross them
            var v01 = vec3.subtract(v1, v0, []);
            var v02 = vec3.subtract(v2, v0, []);
            var cross = vec3.cross(v02, v01, []);
            // add this cross product to the vtxNorStore for the 0th, 1st and 2nd indices
            vtxNorStore[vtxIndStore[i][0]] = vec3.add(vtxNorStore[vtxIndStore[i][0]], cross, []);
            vtxNorStore[vtxIndStore[i][1]] = vec3.add(vtxNorStore[vtxIndStore[i][1]], cross, []);
            vtxNorStore[vtxIndStore[i][2]] = vec3.add(vtxNorStore[vtxIndStore[i][2]], cross, []);
        }
        //		console.log(vtxNorStore);

        var flatArray = [];
        for (var i = 0; i < vtxNorStore.length; i++) {
            vtxNorStore[i] = vec3.normalize(vtxNorStore[i], []);
            flatArray.push(vtxNorStore[i][0]);
            flatArray.push(vtxNorStore[i][1]);
            flatArray.push(vtxNorStore[i][2]);
        }
        //		console.log(flatArray);
        return flatArray;

    };

    this.getVtxInd = function() {
        var flatArray = vtxIndStore[0];
        for (var i = 1; i < vtxIndStore.length; i++) {
            flatArray.push(vtxIndStore[i][0]);
            flatArray.push(vtxIndStore[i][1]);
            flatArray.push(vtxIndStore[i][2]);
        }
        //		console.log(flatArray);
        return flatArray;
    };

    _subDivide(subDivisionDepth);

    var vtxPos = this.getVtxPos();
    var vtxNor = this.getVtxNor();
    var vtxInd = this.getVtxInd();

    var vtxPosBuf;
    var vtxNorBuf;
    var vtxIndBuf;

    if (gl) {
        vtxPosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxPos), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxPos']);
        vtxNorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxNor), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxNor']);
        vtxIndBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vtxInd), gl.STATIC_DRAW);
    }

    this.draw = function(cam) { // camera
        gl.useProgram(sp);

        webgl.common.pushMvMatrix();

        mat4.translate(webgl.common.mvMatrix, p); // translation by p
        //mat4.multiply(webgl.common.mvMatrix, q); // rotation by q

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.vertexAttribPointer(sp['aVtxPos'], 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBuf);
        gl.vertexAttribPointer(sp['aVtxNor'], 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(sp['uPMatrix'], false, webgl.common.pMatrix);
        gl.uniformMatrix4fv(sp['uMvMatrix'], false, webgl.common.mvMatrix);
        gl.uniform3f(sp['uLightDirection'], lightDirection[0], lightDirection[1], lightDirection[2]);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBuf);
        gl.drawElements(gl.TRIANGLES, vtxInd.length, gl.UNSIGNED_SHORT, 0);

        webgl.common.popMvMatrix();
    };
}


// ====
// C:\inetpub\wwwroot\WebGL\code\square.js
// ----
function Square(gl, sp, p) { // gl, shaderProgram, position

    this.getVtxPos = function() {
        return [
            1, 1, 0,
            -1, 1, 0,
            1, -1, 0,
            -1, -1, 0
        ];
    };

    var vtxPos = this.getVtxPos();

    var vtxPosBuf;
    if (gl) {
        vtxPosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxPos), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxPos']);
    }

    this.draw = function(cam) { // camera
        gl.useProgram(sp);

        webgl.common.pushMvMatrix();

        mat4.translate(webgl.common.mvMatrix, p); // translation by p
        //mat4.multiply(webgl.common.mvMatrix, q); // rotation by q

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBuf);
        gl.vertexAttribPointer(sp['aVtxPos'], 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(sp['uPMatrix'], false, webgl.common.pMatrix);
        gl.uniformMatrix4fv(sp['uMvMatrix'], false, webgl.common.mvMatrix);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vtxPos.length / 3);

        webgl.common.popMvMatrix();
    };
}


// ====
// C:\inetpub\wwwroot\WebGL\code\terrain.js
// ----
function Terrain(gl, sp, p, heightmap) { // gl, shaderProgram, position, heightmap
    var self = {};

    var isWireFrame = true;

    self.getP = function () { return p; };

    // note: generalize this for higher LOD buffers, also spheres and noise
    var vtxPos = [];
    var vtxNor = [];
    for (var i = 0; i < 129 * 129; i++) {
        var x = i % 129;
        var y = 0;
        var z = -Math.floor(i / 129);
        vtxPos.push(x);
        vtxPos.push(y);
        vtxPos.push(z);
        vtxNor.push(0);
        vtxNor.push(0);
        vtxNor.push(1);
    }

    //function test(index) {
    //    console.log(vtxPos[index * 3], vtxPos[index * 3 + 1], vtxPos[index * 3 + 2]);
    //}
    //test(16640);

    var vtxPosBufs = {};
    var vtxNorBufs = {};
    var vtxIndBufs = {};

    self.nodes = {};
    self.nodes[1] = new Node(1, heightmap, self);
    self.nodes[2] = new Node(2, heightmap, self);
    self.nodes[3] = new Node(3, heightmap, self);
    self.nodes[4] = new Node(4, heightmap, self);

    self.processed = [];

    if (gl) {
        vtxPosBufs[0] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBufs[0]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxPos), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxPos']);
        vtxNorBufs[0] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBufs[0]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtxNor), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(sp['aVtxNor']);
        vtxIndBufs[0] = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBufs[0]);
    }

    self.getIndexes = function(cam) {
        var indexes = [];
        for (var index in self.nodes) {
            Array.prototype.push.apply(indexes, self.nodes[index].draw(cam));
        }
        return indexes;
    };

    self.draw = function(cam) { // camera
        gl.useProgram(sp);

        webgl.common.pushMvMatrix();

        mat4.translate(webgl.common.mvMatrix, p); // translation by p
        //mat4.multiply(webgl.common.mvMatrix, q); // rotation by q

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxPosBufs[0]);
        gl.vertexAttribPointer(sp['aVtxPos'], 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, vtxNorBufs[0]);
        gl.vertexAttribPointer(sp['aVtxNor'], 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(sp['uPMatrix'], false, webgl.common.pMatrix);
        gl.uniformMatrix4fv(sp['uMvMatrix'], false, webgl.common.mvMatrix);
        gl.uniform3f(sp['uLightDirection'], lightDirection[0], lightDirection[1], lightDirection[2]);

        var indexes = self.getIndexes(cam);
        //console.log(indexes);
        if (false) {
            indexes.forEach(function(ii) {
                if (ii < 0 || ii > vtxPos.length / 3)
                    throw 'Invalid index: ' + ii;
            });
        }
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vtxIndBufs[0]);
        if (!isWireFrame) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexes), gl.STATIC_DRAW);
            gl.drawElements(gl.TRIANGLES, indexes.length, gl.UNSIGNED_SHORT, 0);
        } else {
            var wireFrameIndexes = [];
            for (var j = 0; j < indexes.length; j += 3) {
                wireFrameIndexes.push(indexes[j]);
                wireFrameIndexes.push(indexes[j + 1]);
                wireFrameIndexes.push(indexes[j]);
                wireFrameIndexes.push(indexes[j + 2]);
                wireFrameIndexes.push(indexes[j + 1]);
                wireFrameIndexes.push(indexes[j + 2]);
            }
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(wireFrameIndexes), gl.STATIC_DRAW);
            gl.drawElements(gl.LINES, wireFrameIndexes.length, gl.UNSIGNED_SHORT, 0);
        }

        webgl.common.popMvMatrix();
    };

    return self;
}


// ====
// C:\inetpub\wwwroot\WebGL\code\tests.html
// ----
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Tests</title>
    <link rel="stylesheet" type="text/css" href="qunit.css" />
    <script type="text/javascript" src="jquery-1.4.4.min.js"></script>
    <script type="text/javascript" src="qunit.js"></script>

    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="common.js"></script>
    <script type="text/javascript" src="camera.js"></script>
    <script type="text/javascript" src="node.js"></script>
    <script type="text/javascript" src="terrain.js"></script>

    <script type="text/javascript">
        $(function () {
            module('Example Tests');

            test('example test', function () {
                expect(2); // expected number of assertions
                var statementExpectedToBeTrue = true;
                ok(statementExpectedToBeTrue, 'statementExpectedToBeTrue is indeed true');
                var value = 'hello';
                equal(value, 'hello', 'We expect value to be hello');
            });

            module('Real Tests');

            test('quaternions', function () {
                var testQuat = quat4.fromAngleAxis(0, [0, 0, 0]);
                equal(quat4.str(testQuat, 3), quat4.str([0, 0, 0, 1], 3), 'identity quat');
                var testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis), vec3.str([1, 0, 0]), 'identity quat does not rotate x-axis');

                testQuat = quat4.fromAngleAxis(Math.PI / 2, [0, 1, 0]);
                equal(quat4.str(testQuat, 3), quat4.str([0, 0.707, 0, 0.707], 3), 'half pi around y-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis), vec3.str([0, 0, -1]), 'x-axis half pi around y-axis is -ve z-axis');

                testQuat = quat4.fromAngleAxis(Math.PI, [0, 1, 0]);
                equal(quat4.str(testQuat, 3), quat4.str([0, 1, 0, 0], 3), 'pi around y-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                //equal(vec3.str(testAxis, 3), vec3.str([-1, 0, 0], 3), 'x-axis pi around y-axis is -ve x-axis'); // -ve 0 error!

                testQuat = quat4.fromAngleAxis(2 * Math.PI, [0, 1, 0]);
                equal(quat4.str(testQuat, 3), quat4.str([0, 0, 0, -1], 3), '2 pi around y-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis, 3), vec3.str([1, 0, 0], 3), 'x-axis 2 pi around y-axis is still x-axis');

                testQuat = quat4.fromAngleAxis(Math.PI / 2, [1, 0, 0]);
                equal(quat4.str(testQuat, 3), quat4.str([0.707, 0, 0, 0.707], 3), 'half pi around x-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis, 3), vec3.str([1, 0, 0], 3), 'x-axis around x-axis is still x-axis');

                testQuat = quat4.create([0, 0, 0, 1]);
                halfPiRoundZ = quat4.fromAngleAxis(Math.PI / 2, [0, 0, 1]);
                halfPiRoundX = quat4.fromAngleAxis(Math.PI / 2, [1, 0, 0]);
                quat4.multiply(halfPiRoundZ, testQuat, testQuat);
                quat4.multiply(halfPiRoundX, testQuat, testQuat);
                equal(quat4.str(testQuat, 3), quat4.str([0.5, -0.5, 0.5, 0.5], 3), 'half pi around z-axis, then half pi around x-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis, 3), vec3.str([0, 0, 1], 3), 'x-axis around z-axis then around x-axis is +ve z-axis');
                testQuat = quat4.create([0, 0, 0, 1]);
                quat4.multiply(halfPiRoundX, testQuat, testQuat);
                quat4.multiply(halfPiRoundZ, testQuat, testQuat);
                equal(quat4.str(testQuat, 3), quat4.str([0.5, 0.5, 0.5, 0.5], 3), 'half pi around z-axis, then half pi around x-axis');
                testAxis = quat4.multiplyVec3(testQuat, [1, 0, 0]);
                equal(vec3.str(testAxis, 3), vec3.str([0, 1, 0], 3), 'x-axis around x-axis then around z-axis is +ve y-axis');

                //testQuat = quat4.fromVectors([0,1,0], [0,0,1], []);
                //equal(quat4.str(testQuat, 3), quat4.str([0.707, 0, 0, 0.707], 3), 'from y-axis to z-axis = half-pi around x-axis');
                //testQuat = quat4.fromVectors([0,1,0], [0,1,0], []);
                //equal(quat4.str(testQuat, 3), quat4.str([0, 0, 0, 1], 3), 'identity quat');
                //testQuat = quat4.fromVectors([0,1,0], [0,-1,0], []);
                //equal(quat4.str(testQuat, 3), quat4.str([1, 0, 0, 0], 3), 'identity quat');
            });

            test('camera', function () {
                var cam = new Camera();
                var origin = vec3.create([0, 0, 0]);
                var zDirection = quat4.create([0, 0, 0, 1]);
                equal(vec3.str(cam.p), vec3.str(origin), 'cam starts at origin');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam starts pointing along z-axis');
                cam.advance(4);
                equal(vec3.str(cam.p, 3), vec3.str([0, 0, 4], 3), 'cam advances 4 => translate scene by 4 in +ve z-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');
                cam.advance(-5);
                equal(vec3.str(cam.p, 3), vec3.str([0, 0, -1], 3), 'cam retreats 5 => translate scene by 5 in -ve z-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');
                cam.strafe(3); // sidestep right
                equal(vec3.str(cam.p, 3), vec3.str([-3, 0, -1], 3), 'cam strafes 3 => translate scene by 3 in -ve x-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');
                cam.strafe(-2);
                equal(vec3.str(cam.p, 3), vec3.str([-1, 0, -1], 3), 'cam strafes -2 => translate scene by 2 in +ve x-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');
                cam.fly(7);
                equal(vec3.str(cam.p, 3), vec3.str([-1, -7, -1], 3), 'cam flies up 7 => translate scene by 7 in -ve y-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');
                cam.fly(-9);
                equal(vec3.str(cam.p, 3), vec3.str([-1, 2, -1], 3), 'cam flies down 9 => translate scene by 9 in +ve y-direction');
                equal(quat4.str(cam.q), quat4.str(zDirection), 'cam still pointing along z-axis');

                cam.bank(Math.PI / 2); // rotate anti-clockwise around forward direction
                equal(vec3.str(cam.p, 3), vec3.str([-1, 2, -1], 3), 'cam still in same position after rotation');
                cam.advance(5);
                equal(vec3.str(cam.p, 3), vec3.str([-1, 2, 4], 3), 'cam advance unaffected by bank');
                cam.strafe(3);
                equal(vec3.str(cam.p, 3), vec3.str([-1, -1, 4], 3), 'cam strafe is now up old y-axis');
                cam.fly(3);
                equal(vec3.str(cam.p, 3), vec3.str([2, -1, 4], 3), 'cam fly is now along old -ve x-axis');

                cam.yaw(Math.PI / 2);
                equal(vec3.str(cam.p, 3), vec3.str([2, -1, 4], 3), 'cam still in same position after rotation');
                cam.advance(1);
                equal(vec3.str(cam.p, 3), vec3.str([2, 0, 4], 3), 'cam advance down old y-axis');
                cam.strafe(1);
                equal(vec3.str(cam.p, 3), vec3.str([2, 0, 5], 3), 'cam strafe along old z-axis');
                cam.fly(1);
                equal(vec3.str(cam.p, 3), vec3.str([3, 0, 5], 3), 'cam fly along old -ve x-axis');

                cam.pitch(Math.PI / 2);
                equal(vec3.str(cam.p, 3), vec3.str([3, 0, 5], 3), 'cam still in same position after rotation');
                cam.advance(1);
                equal(vec3.str(cam.p, 3), vec3.str([4, 0, 5], 3), 'cam advance along old -ve x-axis');
                cam.strafe(1);
                equal(vec3.str(cam.p, 3), vec3.str([4, 0, 6], 3), 'cam strafe along old z-axis');
                cam.fly(1);
                equal(vec3.str(cam.p, 3), vec3.str([4, -1, 6], 3), 'cam fly along old y-axis');
            });

            function benchmark(iterations, f) {
                var t1 = new Date().getTime();
                for (var i = 0; i < iterations; i++) {
                    f();
                }
                var t2 = new Date().getTime();
                return t2 - t1;
            }

            test('benchmarking', function () {
                // concatenating arrays...
                // -----------------------
                var iterations = 1E5;//1E6;
                var iterateAndPush = benchmark(iterations, function () {
                    var a = [1, 2, 3];
                    var b = [4, 5, 6];
                    for (var j = 0; j < b.length; j++) a.push(b[j]);
                });
                var pushDotApply = benchmark(iterations, function () {
                    var a = [1, 2, 3];
                    var b = [4, 5, 6];
                    Array.prototype.push.apply(a, b);
                });
                ok(pushDotApply / iterateAndPush < 0.7, 'pushDotApply (' + pushDotApply + ') faster than iterateAndPush (' + iterateAndPush + ')');

                // array contains...
                // -----------------
                iterations = 1E6;//1E7;
                iterateAndCompare = benchmark(iterations, function () {
                    var a = [1, 2, 3];
                    var result = a.contains(2);
                });
                inArray = benchmark(iterations, function () {
                    var a = [1, 2, 3];
                    var result = ($.inArray(2, a) != -1);
                });
                ok(iterateAndCompare / inArray < 0.3, 'iterateAndCompare (' + iterateAndCompare + ') faster than inArray (' + inArray + ')');

                // for loop through 10^8 in 130 ms
                // construct 10^8 arrays in 470 ms
                // construct 10^6 arrays and push two in 45 (three in 50... one in 185!) ms
                // extend 10^6 arrays via iteration in 494 ms
                // extend 10^6 arrays via push.apply in 304 ms
            });

            test('Node.getLevel', function () {
                equal(Node.getLevel(0), 0);
                equal(Node.getLevel(1), 1);
                equal(Node.getLevel(4), 1);
                equal(Node.getLevel(5), 2);
                equal(Node.getLevel(20), 2);
                equal(Node.getLevel(21), 3);
            });

            test('Node.getFirstIndexOfLevel', function () {
                equal(Node.getFirstIndexOfLevel(0), 0);
                equal(Node.getFirstIndexOfLevel(1), 1);
                equal(Node.getFirstIndexOfLevel(2), 5);
                equal(Node.getFirstIndexOfLevel(3), 21);
            });

            test('Node.getXY', function () {
                deepEqual(Node.getXY(0), { x: 0, y: 0 });
                deepEqual(Node.getXY(1), { x: 0, y: 0 });
                deepEqual(Node.getXY(2), { x: 0.5, y: 0 });
                deepEqual(Node.getXY(3), { x: 0, y: 0.5 });
                deepEqual(Node.getXY(5), { x: 0, y: 0 });
                deepEqual(Node.getXY(6), { x: 0.25, y: 0 });
                deepEqual(Node.getXY(9), { x: 0, y: 0.25 });
            });

            test('Node.getChildIndexes', function () {
                deepEqual(Node.getChildIndexes(0), [1, 2, 3, 4]);
                deepEqual(Node.getChildIndexes(1), [5, 6, 9, 10]);
                deepEqual(Node.getChildIndexes(2), [7, 8, 11, 12]);
                deepEqual(Node.getChildIndexes(3), [13, 14, 17, 18]);
                deepEqual(Node.getChildIndexes(4), [15, 16, 19, 20]);
                deepEqual(Node.getChildIndexes(5), [21, 22, 29, 30]);
            });

            test('Node.getParentIndex', function () {
                deepEqual(Node.getParentIndex(1), 0);
                deepEqual(Node.getParentIndex(5), 1);
                deepEqual(Node.getParentIndex(6), 1);
                deepEqual(Node.getParentIndex(8), 2);
                deepEqual(Node.getParentIndex(17), 3);
                deepEqual(Node.getParentIndex(20), 4);
            });

            test('Node.getSiblingIndexes', function () {
                deepEqual(Node.getSiblingIndexes(1), [1, 2, 3, 4]);
            });

            test('Node.getNeighbourIndexes', function () {
                deepEqual(Node.getNeighbourIndexes(0), [0, 0, 0, 0]);
                deepEqual(Node.getNeighbourIndexes(1), [2, 3, 2, 3]);
                deepEqual(Node.getNeighbourIndexes(2), [1, 4, 4, 1]);
                deepEqual(Node.getNeighbourIndexes(3), [1, 4, 4, 1]);
                deepEqual(Node.getNeighbourIndexes(4), [2, 3, 2, 3]);

                deepEqual(Node.getNeighbourIndexes(5), [8, 9, 6, 17]);
                deepEqual(Node.getNeighbourIndexes(6), [7, 10, 7, 5]);
                deepEqual(Node.getNeighbourIndexes(7), [6, 11, 8, 6]);
                deepEqual(Node.getNeighbourIndexes(8), [5, 12, 20, 7]);
                deepEqual(Node.getNeighbourIndexes(9), [5, 13, 10, 13]);
                deepEqual(Node.getNeighbourIndexes(12), [8, 16, 16, 11]);
                deepEqual(Node.getNeighbourIndexes(13), [9, 17, 14, 9]);
                deepEqual(Node.getNeighbourIndexes(16), [12, 20, 12, 15]);
                deepEqual(Node.getNeighbourIndexes(17), [13, 20, 18, 5]);
                deepEqual(Node.getNeighbourIndexes(18), [14, 19, 19, 17]);
                deepEqual(Node.getNeighbourIndexes(19), [15, 18, 20, 18]);
                deepEqual(Node.getNeighbourIndexes(20), [16, 17, 8, 19]);

                deepEqual(Node.getNeighbourIndexes(21), [28, 29, 22, 77]);
                deepEqual(Node.getNeighbourIndexes(28), [21, 36, 84, 27]);
                deepEqual(Node.getNeighbourIndexes(77), [69, 84, 78, 21]);
                deepEqual(Node.getNeighbourIndexes(84), [76, 77, 28, 83]);
            });

            test('Node.getIndexes', function () {
                deepEqual(Node.getIndexes(1, [false, false, false, false]), [4160, 0, 64, 4160, 64, 8320, 4160, 8320, 8256, 4160, 8256, 0]);
                deepEqual(Node.getIndexes(2, [false, false, false, false]), [4224, 64, 128, 4224, 128, 8384, 4224, 8384, 8320, 4224, 8320, 64]);
                deepEqual(Node.getIndexes(3, [false, false, false, false]), [12416, 8256, 8320, 12416, 8320, 16576, 12416, 16576, 16512, 12416, 16512, 8256]);
                deepEqual(Node.getIndexes(4, [false, false, false, false]), [12480, 8320, 8384, 12480, 8384, 16640, 12480, 16640, 16576, 12480, 16576, 8320]);

                deepEqual(Node.getIndexes(5, [false, false, false, false]), [2080, 0, 32, 2080, 32, 4160, 2080, 4160, 4128, 2080, 4128, 0]);

                deepEqual(Node.getIndexes(1, [true, false, false, false]), [4160, 0, 32, 4160, 32, 64, 4160, 64, 8320, 4160, 8320, 8256, 4160, 8256, 0]);
                deepEqual(Node.getIndexes(1, [false, true, false, false]), [4160, 0, 64, 4160, 64, 8320, 4160, 8320, 8288, 4160, 8288, 8256, 4160, 8256, 0]);
                deepEqual(Node.getIndexes(1, [false, false, true, false]), [4160, 0, 64, 4160, 64, 4192, 4160, 4192, 8320, 4160, 8320, 8256, 4160, 8256, 0]);
                deepEqual(Node.getIndexes(1, [false, false, false, true]), [4160, 0, 64, 4160, 64, 8320, 4160, 8320, 8256, 4160, 8256, 4128, 4160, 4128, 0]);
            });

            test('Node.getSize', function () {
                equal(Node.getSize(0), 128);
                equal(Node.getSize(1), 64);
                equal(Node.getSize(5), 32);
            });

            test('Node.getCentre', function () {
                deepEqual(Node.getCentre(0), vec3.create([64, 0, 64]));
                deepEqual(Node.getCentre(1), vec3.create([32, 0, 32]));
                deepEqual(Node.getCentre(2), vec3.create([96, 0, 32]));
                deepEqual(Node.getCentre(3), vec3.create([32, 0, 96]));
                deepEqual(Node.getCentre(5), vec3.create([16, 0, 16]));
            });

            test('node specific', function () {
                //var cam = new Camera();
                //var terrain = {
                //    processed: [],
                //    getP: function () { return [0, 0, 0]; }
                //};
                //var node = new Node(1, null, terrain);
                //var splitOrMerge = node.getSplitOrMerge(cam);
                //equal(splitOrMerge, Node.splitOrMerge.SPLIT, 'node should split');
                //ok(terrain.processed.contains(1), 'node flagged as processed');
            });

            test('terrain', function () {
                var cam = new Camera();
                var terrain = new Terrain(null, null, vec3.create([0, -1, 0]), null);
                var indexes = terrain.getIndexes(cam);
                //console.log(terrain.nodes);
                console.log(indexes);
                //deepEqual(indexes, [4160, 0, 32, 4160, 32, 64, 4160, 64, 4224, 4160, 4224, 8320, 4160, 8320, 12416, 4160, 12416, 8256, 4160, 8256, 4128, 4160, 4128, 0, 4224, 64, 128, 4224, 128, 128, 4224, 128, 8384, 4224, 8384, 8320, 4224, 8320, 4224, 4224, 4224, 64, 12416, 8256, 12416, 12416, 12416, 8320, 12416, 8320, 16576, 12416, 16576, 16512, 12416, 16512, 16512, 12416, 16512, 8256, 12480, 8320, 8384, 12480, 8384, 16640, 12480, 16640, 16576, 12480, 16576, 8320]);
                //deepEqual(indexes, [4160, 0, 64, 4160, 64, 8320, 4160, 8320, 8256, 4160, 8256, 0, 4224, 64, 128, 4224, 128, 8384, 4224, 8384, 8320, 4224, 8320, 64, 12416, 8256, 8320, 12416, 8320, 16576, 12416, 16576, 16512, 12416, 16512, 8256, 12480, 8320, 8384, 12480, 8384, 16640, 12480, 16640, 16576, 12480, 16576, 8320]);
                deepEqual(terrain.processed, [1, 2, 4, 3]);
                //console.log(terrain.nodes);
                var indexes = terrain.getIndexes(cam);
                //deepEqual(terrain.processed, [1, 2, 3, 4, 5, 6, 9, 10]);

                //var indexes = terrain.getIndexes(cam);
                //deepEqual(terrain.processed, [1, 2, 3, 4, 5, 6, 9, 10]);
                //deepEqual(indexes, [4160, 0, 64, 4160, 64, 8320, 4160, 8320, 8256, 4160, 8256, 0, 4224, 64, 128, 4224, 128, 8384, 4224, 8384, 8320, 4224, 8320, 64, 12416, 8256, 8320, 12416, 8320, 16576, 12416, 16576, 16512, 12416, 16512, 8256, 12480, 8320, 8384, 12480, 8384, 16640, 12480, 16640, 16576, 12480, 16576, 8320]);
                //deepEqual(indexes, [4224, 64, 128, 4224, 128, 8384, 4224, 8384, 8320, 4224, 8320, 64, 12416, 8256, 8320, 12416, 8320, 16576, 12416, 16576, 16512, 12416, 16512, 8256, 12480, 8320, 8384, 12480, 8384, 16640, 12480, 16640, 16576, 12480, 16576, 8320]);

                //-100, -1, -100
            });

        });
    </script>
  
</head>
<body>
    <h1 id="qunit-header">QUnit example</h1>
    <h2 id="qunit-banner"></h2>
    <div id="qunit-testrunner-toolbar"></div>
    <h2 id="qunit-userAgent"></h2>
    <ol id="qunit-tests"></ol>
    <div id="qunit-fixture">test markup, will be hidden</div>
</body>
</html>


// ====
// C:\inetpub\wwwroot\WebGL\code\webgl-utils.js
// ----
/*
* Copyright 2010, Google Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are
* met:
*
*     * Redistributions of source code must retain the above copyright
* notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above
* copyright notice, this list of conditions and the following disclaimer
* in the documentation and/or other materials provided with the
* distribution.
*     * Neither the name of Google Inc. nor the names of its
* contributors may be used to endorse or promote products derived from
* this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/**
* @fileoverview This file contains functions every webgl program will need
* a version of one way or another.
*
* Instead of setting up a context manually it is recommended to
* use. This will check for success or failure. On failure it
* will attempt to present an approriate message to the user.
*
*       gl = WebGLUtils.setupWebGL(canvas);
*
* For animated WebGL apps use of setTimeout or setInterval are
* discouraged. It is recommended you structure your rendering
* loop like this.
*
*       function render() {
*         window.requestAnimFrame(render, canvas);
*
*         // do rendering
*         ...
*       }
*       render();
*
* This will call your rendering function up to the refresh rate
* of your display but will stop rendering if your app is not
* visible.
*/

WebGLUtils = function () {

    /**
    * Creates the HTLM for a failure message
    * @param {string} canvasContainerId id of container of th
    *        canvas.
    * @return {string} The html.
    */
    var makeFailHTML = function (msg) {
        return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + msg + '</div>' +
    '</div>' +
    '</td></tr></table>';
    };

    /**
    * Mesasge for getting a webgl browser
    * @type {string}
    */
    var GET_A_WEBGL_BROWSER = '' +
  'This page requires a browser that supports WebGL.<br/>' +
  '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

    /**
    * Mesasge for need better hardware
    * @type {string}
    */
    var OTHER_PROBLEM = '' +
  "It doesn't appear your computer can support WebGL.<br/>" +
  '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

    /**
    * Creates a webgl context. If creation fails it will
    * change the contents of the container of the <canvas>
    * tag to an error message with the correct links for WebGL.
    * @param {Element} canvas. The canvas element to create a
    *     context from.
    * @param {WebGLContextCreationAttirbutes} opt_attribs Any
    *     creation attributes you want to pass in.
    * @param {function:(msg)} opt_onError An function to call
    *     if there is an error during creation.
    * @return {WebGLRenderingContext} The created context.
    */
    var setupWebGL = function (canvas, opt_attribs, opt_onError) {
        function handleCreationError(msg) {
            var container = canvas.parentNode;
            if (container) {
                var str = window.WebGLRenderingContext ?
           OTHER_PROBLEM :
           GET_A_WEBGL_BROWSER;
                if (msg) {
                    str += "<br/><br/>Status: " + msg;
                }
                container.innerHTML = makeFailHTML(str);
            }
        };

        opt_onError = opt_onError || handleCreationError;

        if (canvas.addEventListener) {
            canvas.addEventListener("webglcontextcreationerror", function (event) {
                opt_onError(event.statusMessage);
            }, false);
        }
        var context = create3DContext(canvas, opt_attribs);
        if (!context) {
            if (!window.WebGLRenderingContext) {
                opt_onError("");
            }
        }
        return context;
    };

    /**
    * Creates a webgl context.
    * @param {!Canvas} canvas The canvas tag to get context
    *     from. If one is not passed in one will be created.
    * @return {!WebGLContext} The created context.
    */
    var create3DContext = function(canvas, opt_attribs) {
        var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
        var context = null;
        for (var ii = 0; ii < names.length; ++ii) {
            try {
                context = canvas.getContext(names[ii], opt_attribs);
            } catch(e) {
            }
            if (context) {
                break;
            }
        }
        return context;
    };

    return {
        create3DContext: create3DContext,
        setupWebGL: setupWebGL
    };
} ();

/**
* Provides requestAnimationFrame in a cross browser way.
*/
window.requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function (/* function FrameRequestCallback */callback, /* DOMElement Element */element) {
             window.setTimeout(callback, 1);
         };
})();


// ====
// C:\inetpub\wwwroot\WebGL\code\webgl.js
// ----
var webgl = webgl || {};

// note: can push some uniforms to GPU once per shader program, e.g. pMatrix, lightDirection, etc

webgl.common = (function () {
    var self = {};

// ReSharper disable InconsistentNaming
    var _viewportWidth = null;
    var _viewportHeight = null;
    var _t1 = new Date().getTime();
    var _benchmarker = null;
    var _mvMatrixStack = []; // stack of model-view matrices

    var _shaderProgram2d = null;
    var _shaderProgram3d = null;
// ReSharper restore InconsistentNaming

    self.gl = null;
    self.cam = null;
    self.objects = [];
    self.transparentObjects = [];
    self.pMatrix = mat4.create(); // perspective matrix
    self.mvMatrix = mat4.create(); // model-view matrix

    self.init = function (canvas, $benchmarker) {
        try {
            self.gl = canvas.getContext('experimental-webgl');
            _viewportWidth = canvas.width;
            _viewportHeight = canvas.height;
        } catch(e) {
        }

        if (!self.gl) {
            window.alert('Could not initialise WebGL');
            throw 'Could not initialise WebGL';
        }

        self.gl.viewport(0, 0, _viewportWidth, _viewportHeight);
        self.gl.clearColor(0, 0, 0, 1);
        self.gl.enable(self.gl.DEPTH_TEST);
        self.gl.blendFunc(self.gl.SRC_ALPHA, self.gl.ONE_MINUS_SRC_ALPHA);
        mat4.perspective(45, _viewportWidth / _viewportHeight, 0.1, 10000, self.pMatrix);
        window.document.onkeydown = handleKeyDown;
        window.document.onkeyup = handleKeyUp;

        self.cam = new Camera();

        initBenchmarker($benchmarker);
        initShaderPrograms();
        initObjects();

        self.tick();
    };

    self.pushMvMatrix = function() {
        var copy = mat4.create();
        mat4.set(self.mvMatrix, copy);
        _mvMatrixStack.push(copy);
    };

    self.popMvMatrix = function() {
        if (_mvMatrixStack.length == 0)
            throw 'No matrices on stack to pop';

        self.mvMatrix = _mvMatrixStack.pop();
    };

    self.tick = function () {
        if (_benchmarker && !_benchmarker.run)
            return;

        requestAnimFrame(self.tick);

        var t2 = new Date().getTime();
        if (_t1 && _benchmarker)
            _benchmarker.setFrameTime(t2 - _t1);
        _t1 = new Date().getTime();

        handleKeys();
        draw();
    };

    function initBenchmarker($benchmarker) {
        _benchmarker = new Benchmarker($benchmarker);
        _benchmarker.createBins(10);
    }

    function draw() {
        self.gl.clear(self.gl.COLOR_BUFFER_BIT | self.gl.DEPTH_BUFFER_BIT);

        // start model-view matrix at the origin...
        mat4.identity(self.mvMatrix);
        // ... then apply camera rotation...
        mat4.multiply(self.mvMatrix, quat4.toMat4(self.cam.q));
        // ... then camera translation...
        mat4.translate(self.mvMatrix, self.cam.p);

        // opaque objects
        self.gl.disable(self.gl.BLEND);
        for (var i = 0; i < self.objects.length; i++) {
            self.objects[i].draw(self.cam);
        }

        // transparent objects
        self.gl.enable(self.gl.BLEND);
        for (i = 0; i < self.transparentObjects.length; i++) { // TODO: order back to front
            self.transparentObjects[i].draw(self.cam);
        }
    }

    function initShaderPrograms() {
        _shaderProgram2d = new ShaderProgram(self.gl, 'shaders/shader2d.vert', 'shaders/shader2d.frag'); // aVtxPos and aVtxNor
        _shaderProgram2d.setUniformLocation('uPMatrix');
        _shaderProgram2d.setUniformLocation('uMvMatrix');
        _shaderProgram2d.setAttribLocation('aVtxPos');

        _shaderProgram3d = new ShaderProgram(self.gl, 'shaders/shader3d.vert', 'shaders/shader3d.frag'); // aVtxPos and aVtxNor
        _shaderProgram3d.setUniformLocation('uPMatrix');
        _shaderProgram3d.setUniformLocation('uMvMatrix');
        _shaderProgram3d.setUniformLocation('uLightDirection');
        _shaderProgram3d.setAttribLocation('aVtxPos');
        _shaderProgram3d.setAttribLocation('aVtxNor');
    }

    function initObjects() {
        //var cube = new Cube(self.gl, _shaderProgram3d, vec3.create([-3, -2, -10]));
        //self.objects.push(cube);

        //var transparentSquare = new Square(self.gl, _shaderProgram2d, vec3.create([-0.8, 0.8, -13]));
        //self.transparentObjects.push(transparentSquare);
        //var transparentSquare2 = new Square(self.gl, _shaderProgram2d, vec3.create([0.8, -0.8, -9]));
        //self.transparentObjects.push(transparentSquare2);

        //var noise = new SimplexNoise();
        //var adjust = function(v) {
        //    //return [v[0], v[1], v[2]];
        //    var n = 600;
        //    var radius = 1 + 0.01 * noise.noises3d(2 * v[0] / n, 2 * v[1] / n, 2 * v[2] / n, 4, 0.95);
        //    return [radius * v[0], radius * v[1], radius * v[2]];
        //};

        //var sphere = new Sphere(self.gl, _shaderProgram3d, vec3.create([0,-310,0]), 300, 6, adjust);
        //self.objects.push(sphere);
        //var sphere2 = new Sphere(self.gl, _shaderProgram3d, vec3.create([0, -151, -500]), 200, 4, adjust);
        //self.objects.push(sphere2);

        //var grid = new Grid(self.gl, _shaderProgram3d, vec3.create([0, -1, 0]), 16);
        //self.objects.push(grid);

        self.cam.yaw(-Math.PI / 4);
        var terrain = new Terrain(self.gl, _shaderProgram3d, vec3.create([-0, -1, -0]));
        self.objects.push(terrain);
    }

    return self;
}());



